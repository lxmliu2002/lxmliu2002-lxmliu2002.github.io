<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem | lxmliu2002&#39;s Blog</title>
<meta name="keywords" content="Binary-Code-Search, Vulnerability-Search">
<meta name="description" content="PaperReading">
<meta name="author" content="lxmliu2002">
<link rel="canonical" href="https://lxmliu2002.github.io/posts/paperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lxmliu2002.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lxmliu2002.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lxmliu2002.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lxmliu2002.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lxmliu2002.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lxmliu2002.github.io/posts/paperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://lxmliu2002.github.io/posts/paperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem/">
  <meta property="og:site_name" content="lxmliu2002&#39;s Blog">
  <meta property="og:title" content="PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem">
  <meta property="og:description" content="PaperReading">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-03-25T00:00:00+00:00">
    <meta property="article:tag" content="Binary-Code-Search">
    <meta property="article:tag" content="Vulnerability-Search">
    <meta property="og:image" content="https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg">
<meta name="twitter:title" content="PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem">
<meta name="twitter:description" content="PaperReading">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lxmliu2002.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem",
      "item": "https://lxmliu2002.github.io/posts/paperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem",
  "name": "PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem",
  "description": "PaperReading",
  "keywords": [
    "Binary-Code-Search", "Vulnerability-Search"
  ],
  "articleBody": "How Machine Learning Is Solving the Binary Function Similarity Problem 通读 Abstract 精确计算两段二进制代码之间的相似度的能力在许多不同的问题中起着重要的作用。本文对该领域的最新技术进行评估研究。首先将其系统化，确定了代表三个不同社区新提出的解决方案。本文重新实现这些方案并使用不同编译器、优化选项和三种不同编译架构创建了一个新数据集。以此系统评估二进制相似度方法。\nIntroduction 二元函数相似度是指将一对函数的二进制表示作为输入，生成一个数值表示二者间的相似性。但是，不同的编译工具链、优化选项等，会使得简单的判定方法失效。\nChallenges 第一个挑战是目前既不能重现也不能复制以前的结果。由于重新实现以前的技术非常复杂且非常耗时，因此每个解决方案通常只与以前的几个技术进行比较，这些技术有时甚至不是为了解决相同的问题而设计的，并且在某些极端情况下，只与同一作者的先前论文进行比较。\n第二个挑战是评估结果往往是不透明的。不同的解决方案通常是针对略有不同的目标（搜索漏洞 vs. 发现类似的恶意软件样本)，在不同的设置（交叉编译器 vs. 交叉架构)，通过使用不同的相似性概念（相同的代码 vs. 相同的语义)，并在不同的粒度（代码片段 vs. 整个函数)操作。实验也在不同大小和性质的数据集上进行（firmware vs. 命令行实用程序)，并通过使用不同的指标（ROC 曲线 vs. top-n vs. MRR10)报告结果。因此每篇论文中的数值都无法直接比较。而且，不同的论文并不指明特定情景，且不说明其过滤掉细节、如何进行训练等，使得其难以再现。\n不同的环境的可靠性实际上是如何影响性能是不得知的，即不清楚给定方法的优越结果是否与一些新的贡献有关。这两个挑战的综合影响导致形成了一个极其碎片化的领域，存在数十种技术，但没有明确了解哪种技术在哪种环境下有效（或无效）。这给我们带来了最后一个挑战：很难理解二进制相似性研究的方向。每个新的解决方案都采用了一种更复杂的技术，或者是多种技术的新组合，很难判断这是由更简单方法的实际限制驱动的，还是由需要说服审稿人相信每个工作的新颖性驱动的。这种碎片化通常会导致平行和不相交的研究方向，每个人都声称具有最佳的解决方案。这种碎片化也导致了评估和方法次优的论文。\nContributions 本文对该研究领域进行了一个系统评估。首先探索现有的研究，并根据所采用的方法对每个解决方案进行分组，特别关注最近基于机器学习的成功技术。然后选择、比较和实现十种最具代表性的方法及其可能的变体。这些方法代表了广泛的趋势，跨越了三个不同的研究社区：计算机安全，编程语言分析，以及机器学习社区。为了使得比较有意义，本文对实现建立在一个共同的框架之上。并利用并行编程和高效的编码技术避免对模型性能产生负面瓶颈。\n通过重新实现各种方法（不一定是“论文”），本文分离出现有的“原语”，并在单独使用或相互结合使用时对它们进行评估，以获得见解并确定隐藏在先前作品复杂性中的重要因素，并回答各种开放的研究问题。为了使评估工作更具可比性，本文还提出了一个新的数据集，作为不同方面（如编译器系列、优化和体系结构)的通用基准。\n本文侧重于评估迄今为止提出的主要技术，而非重现论文报告中的准确数据。\n本文还发现了几个有趣的见解。例如，我们发现，虽然简单的方法（例如，模糊散列）在简单的设置中工作得很好，但在处理更复杂的场景时（例如跨架构数据集，或多个变量同时变化的数据集），它们就失败了。在机器学习模型中，基于图神经网络的模型在几乎所有任务中都取得了最好的结果，并且在比较推理时间时是最快的。另一个有趣的发现是，许多最近发表的论文在同一数据集上进行测试时都具有非常相似的准确性，尽管有几篇论文声称在技术水平上有所改进。\n虽然我们不声称我们的代码或数据集比以前的作品更好或更有代表性，但我们发布了我们的模块化框架，重新实现了所有选定的方法，完整的数据集，以及如何重新创建和调整它的详细说明通过允许社区对单个组件进行实验并直接相互比较，我们希望鼓励和减轻未来对接近这一活跃研究领域感兴趣的研究人员的努力。\nThe Binary Function Similarity Problem 在其最简单的形式中，二进制函数相似性旨在计算一个数值，该数值捕获一对函数在其二进制表示中的“相似性”，即由编译器生成的构成函数体的原始字节（即机器代码)。请注意，在本文中，我们关注的是使用函数作为代码单元的方法，研究人员也研究了专注于低级抽象（例如，基本块)或高级抽象（例如，整个程序)的技术。根据我们的定义，两个“相似”函数可能具有截然不同的二进制表示——这就是这使得这个研究问题变得有趣且具有挑战性的原因。\n二进制函数相似度已经在一百多篇论文中得到了研究。使情况更加复杂的是，大多数现有的方法不能映射到单一的技术类别，因为它们通常构建在不同的组件之上。在此，专注于这些方法组合的不同构建块，首先查看计算相似性的技术，然后查看这些方法可以利用的输入数据类型。\nMeasuring Function Similarity Direct vs. indirect comparison 我们可以将测量函数相似性的技术分为两大类。第一类解决方案通过考虑原始输入数据或实现某种特征提取来实现函数对的直接比较。这些解决方案通常需要了解两个看似不相关的值可以表示相似的函数，反之亦然，接近的值不一定表示相似的东西。当从二进制函数中提取的特征不能通过使用基本相似性度量直接进行比较时，就会出现这种情况，因为它们可能没有在线性空间中表示，或者可能在相似性得分上没有等效的权重。因此，研究人员建议使用机器学习模型来确定两个函数是否相似，并给出一组提取的特征作为输入。有几种方法可以通过利用贝叶斯网络、卷积神经网络、图匹配网络（GMN）、规则前馈神经网络或它们的组合来实现这种类型的相似性。在这些情况下，该模型用于输出一对函数之间的相似性得分。\n为了找到类似的函数，这些方法需要搜索整个数据集，并将查询函数的特征与数据集中的每个条目进行比较，这不是一个可扩展的解决方案。出于这个原因，许多方法实现了索引策略，通过诸如基于树的数据结构、局部敏感散列（近似最近邻搜索）、bloom 过滤器、基于更简单数据的自定义预过滤器、聚类技术，甚至分布式搜索方法（如 map-reduce）来预过滤潜在的相似候选。\n第二类解决方案实现了间接比较技术。这些方法将输入特征映射为“浓缩”的低维表示，可以使用距离度量（如欧几里得距离或余弦距离）轻松地相互比较。这些解决方案允许高效的一对多比较。例如，如果需要将一个新函数与整个数据集进行比较，可以首先将存储库中的每个函数映射到其各自的低维表示（这是一次性操作），然后对新函数执行相同的操作，最后通过使用近似最近邻等有效技术比较这些表示。\nFuzzy hashes and embeddings. 低维表示的一个流行的例子是模糊散列。模糊哈希是由与传统加密哈希不同的算法产生的，因为它们被有意设计为将类似的输入值映射到类似的哈希。结论是输入原始字节的微小变化会显著影响生成的散列。然而，即使普通模糊哈希可能不适合函数相似性，一些方法（如 FunctionSimSearch）已经提出了更专门的哈希技术来比较两个函数。\n另一种流行的低维表示形式依赖于 embeddings。这个术语在机器学习社区中很流行，指的是一个低维空间，在这个空间中，语义上相似的输入被映射到彼此接近的点，而不管输入在其原始表示中看起来有多么不同。机器学习模型的目标是学习如何产生 embeddings，使相似函数之间的相似性最大化，并使不同函数之间的相似性最小化。在文献中，我们可以识别出两种主要类型的 embeddings：一种试图总结每个函数的代码，另一种试图总结它们的图结构。\nCode embeddings 许多研究者试图利用现有的自然语言处理（NLP）技术，通过将汇编代码作为文本处理来解决二值函数相似问题。这些解决方案处理 token 流（例如，指令、助记符、操作数、规范化指令），每个代码块输出一个 embedding，每个指令输出一个 embedding，或者两者都输出。第一类方法（如 Asm2Vec）基于 word2vec，这是自然语言处理领域的一种知名技术。尽管这些模型不是为跨架构嵌入生成而设计的，但它们可以同时在不同的指令集上进行训练，学习不同语言的语法（但不能跨语言映射语义)，或者它们可以应用于中间语言之上。第二种解决方案基于 seq2seq 编码器 - 解码器模型，该模型允许将不同架构的语义映射到相同的 embedding 空间，从而学习跨架构的相似性。第三种类型的模型建立在 BERT 之上，这是基于 NLP 中最先进的预训练模型。例如，OrderMatters 使用在四个任务上预训练的 BERT 模型来生成基本的块 embedding，而 Trex 使用分层转换器和掩码语言建模任务来学习近似的程序执行语义，然后将学习到的知识转移到识别语义相似的函数。\n汇编代码 embedding 通常受到它们可以处理的不同指令的数量（所谓的词汇表外问题（OOV））以及可以作为模型输入提供的最大指令数量的影响。因此，某些方法计算指令级 embedding，基本块 embedding 或函数级 embedding。指令或基本块 embedding 有时利用其他算法（如最长公共子序列）来计算函数相似性，或者它们被用作更复杂模型的一部分。\nGraph embeddings 另一项研究建立在计算图嵌入的机器学习方法上。这些非常适合捕获基于函数控制流图的特性，本质上是跨架构的。这些嵌入可以通过自定义算法或更复杂的机器学习技术生成，例如图神经网络（GNN）。最近来自机器学习社区的一些方法提出了 GNN 的变体，例如图匹配网络（GMN）。这些变化能够在向量空间中产生可比较的嵌入，其特殊性在于这些嵌入对作为模型输入的两个图中的信息进行编码。\n图嵌入方法还经常将每个基本块的信息编码到图的相应节点中，以增加表达性。例如，一些解决方案为每个节点计算一组属性，从而产生有属性控制流图（attributecontrolflow Graphs, ACFG），ACFG 可以手工设计，也可以以无监督的方式自动学习。其他作者利用前面讨论的一些技术利用其他嵌入计算层（例如，在基本块级别）。\nFunction Representations 二进制函数本质上是与特定于体系结构的机器码和数据相对应的字节流。从这个原始输入开始，研究人员使用了许多方法来提取更高级的信息，这些信息可以用来判断两个函数是否来自相同的源代码。该列表按抽象级别的增加排序，包括以下类别。\nRaw bytes 一些解决方案直接使用原始二进制信息作为相似性度量的起点。\nAssembly 汇编指令是由反汇编器获得的，当可以根据指令大小或操作数以多种不同的方式对操作进行编码时，汇编指令是有用的。\nNormalized assembly 汇编代码通常对常量进行编码，导致操作数和操作数的潜在组合数量较多。使用归一化汇编指令抽象出部分可变性，减少词汇量，并将相同操作的所有可能变化聚合到单个表示中。\nIntermediate representations 有些方法通过将二进制表示提升到中间表示（IR），在更高的抽象级别上工作。IR 的使用带来了几个优点：它可以统一语义等价但句法上不同的指令的表示；它可能会抽象出不同架构的非相关工件；它允许应用程序分析技术来简化（和收敛）某些代码结构。\nStructure 许多方法试图捕捉给定函数的内部结构，或者函数在整个程序中扮演的角色。\nData flow analysis 在程序集级别的算术表达式的实现可以采用不同的形式来实现相同的语义。\nDynamic analysis 一些方法依赖于动态分析。\nSymbolic execution and analysis 与具体的动态执行相反，一些方法依赖于符号执行来完全捕获分析下函数的行为，并在所有可能的路径下确定其输入与其输出之间的关系。\nSelected Approaches 本文的主要贡献之一是位许多关键方法提供实现参考，并在公开和全面的数据集上进行实验来予以比较。理想情况下，人们会评估尽可能多的方法，但显然，重新实现它们是不可行的。同样重要的是要明白，虽然有数百篇关于该主题的论文，但其中许多都是相同技术的小变化，而新颖解决方案的数量明显较少。\nSelection Criteria Scalability and real-world applicability 我们对有可能扩展到大型数据集的方法感兴趣，这些方法可以应用于现实世界的用例。因此，我们不评估那些固有的缓慢且只关注直接比较的方法，例如基于动态分析、符号执行或高复杂性图相关算法的方法。\nFocus on representative approaches and not on specific papers 有许多研究工作提出了相同方法的小变化，例如，通过重用以前的技术，同时稍微改变使用的特征。这通常会导致相似的总体精度，这使得它们在我们的比较中不那么有趣。\nCover different communities 对二值函数相似度问题的研究贡献来自不同的研究团体和学术界和工业界。本文希望概括来自多个社区的代表性研究，同时还考虑了行业提出的方法。\nPrioritize latest trends 虽然这一研究领域的第一个贡献可以追溯到十多年前，但最近兴趣激增。本文综合考虑了各种类型的方法，在此基础上，优先考虑最新的研究。\nSelected Approaches 根据分析，确定了 30 种技术，如图 1 所示，然后我们从中选择了 10 种具有代表性的解决方案用于我们的研究。\n左图显示了根据各自研究小组聚类的方法。这些团体来自学术界和工业界——谷歌和腾讯在这一领域都非常活跃。边线代表其他的解决方案，每篇论文将其结果与之比较。例如，Gemini 和 Genius 之间的箭头表示作者将 Gemini 的结果与 Genius 先前获得的结果进行了比较（两者来自同一组）。图 1 的右侧部分在 Y 轴上显示发布的时间轴，在 X 轴上显示不同类型的输入数据。然后根据计算相似度的不同方法将这些方法聚类为三大类，即模糊哈希、图嵌入和代码嵌入。\n这两个图片都使用标签（括号中）来识别社区（[S] 安全性，[PL] 编程语言，[ML] 机器学习，以及 [SE] 软件工程）。我们还使用 [Mono] 和 [Cross] 标签来表示所提出的方法是否分别关注单架构或跨架构场景。\n即使图 1 中的图表并不全面，只显示了我们选择的论文，它也再次描述了几篇论文如何仅与之前有限的一组方法进行比较。我们还可以从这些图中提取出其他有趣的信息。首先，在中间框中分组的二进制区分工具都是为直接比较两个二进制文件而设计的（例如，它们使用调用图），并且它们都是单一架构的。其次，图表显示，不同的社区往往是相当封闭的，他们很少与其他领域的论文进行比较。这是推进函数相似度研究的明显局限性，我们希望本文能够促进不同领域之间的合作。最后，我们可以找出一些开创性的论文，如 Gemini 和 discoverRE，这些论文在其他研究中被重新实施和广泛测试。这些工作显然激励了其他研究人员提高技术水平。\n右边的时间轴图显示了一个明显的趋势：解决方案的复杂性和机器学习的使用随着时间的推移而增长。我们使用这些信息和图中描述的关系来选择 10 个最先进的解决方案，这些解决方案是可伸缩的、具有代表性的和最新的。与此同时，我们试图最大化研究团体之间的差异。\nBytes fuzzy hashing: Catalog1 Catalog1 是一种基于 MinHash 局部敏感哈希的模糊哈希方法。该算法以函数字节作为输入并产生固定长度的签名，这是比较来自同一架构的功能的一种有前途的方法。\nCFG fuzzy hashing: FunctionSimSearch FunctionSimSearch 使用 SimHash 算法计算模糊散列，该散列结合了从 CFG、助记符中提取的graphlet（即小连通、非同构、诱导子图）和来自汇编代码的直接值。\nAttributed CFG and GNN: Gemini Gemini 使用 GNN (Structure2vec) 从函数 ACFG（即具有基本块级别属性的控制流图）开始计算函数嵌入。这种方法标志着一个里程碑，因为它是第一个使用带有 Siamese 架构的 GNN 来学习函数相似性的人。\nAttributed CFG, GNN, and GMN: Li et al. 2019 一种新颖的图匹配模型来计算图对之间的相似性。作者探索了函数相似性作为实际用例之一。\nIR, data flow analysis and neural network: Zeek Zeek 在基本块级别对提升代码（VEX IR）执行数据流分析（切片），并计算链。然后，训练一个两层全连接神经网络来学习跨架构相似性任务。这种方法是结合中间表示、数据流分析和机器学习的高级建议。\nAssembly code embedding: Asm2Vec Asm2Vec NLP 模型源自 paragraph2vec 的 PV-DM 变体，这是原始 word2vec 模型的扩展。Asm2Vec 引入了更精细的指令级拆分和嵌入构造，以克服具有装配指令的词汇外 (OOV) 问题的局限性。这种方法是完全无监督的，并在单架构实验中取得了最先进的结果。\nAssembly code embedding and self-attentive encoder: SAFE SAFE 使用自我注意句子编码器来学习跨体系结构函数嵌入。这种方法代表了来自 seq2seq 模型的 NLP 编码器，并且与 Asm2Vec 相比，它是专门为学习跨架构相似性而设计的。\nAssembly code embedding, CFG and GNN: Massarelli et al., 2019 Mamasarelli 等人使用了 Gemini 相同的 Structure2vec GNN，但它改变了块级特征，从手动设计的特征切换到无监督特征。它是 Gemini 的演变，结合了指令级嵌入、基本块编码器和 GNN 的优点。\nCodeCMR/BinaryAI 只关注以二进制格式处理函数的部分。该模型将中间表示与 NLP 编码器相结合以获得基本块嵌入和 GNN 以获得图嵌入。两个 LSTM 从函数中编码字符串和整数数据。函数嵌入是三个的串联，二进制模型是端到端训练的。\nTrex Trex 是最近基于分层 Transformer 和微跟踪的工作。本文提出了一种提取函数轨迹的动态组件，这是学习函数语义的基础。作者在这些轨迹上预训练 ML 模型，并转移学习到的知识以匹配语义相似的函数。匹配阶段完全基于静态特征，而模拟生成微跟踪只需要在预训练期间。这种跨架构解决方案建立在 Transformer 之上，Transformer 是 NLP 中最先进的深度学习模型。\nEvaluation Implementation 本文是为了在不同的方法之间进行相对公平的比较。基于此，作者以统一的方式完成了评估的各个阶段，包括二进制分析、特征提取和机器学习实现，创建一个共同点以对不同的方法进行有意义和公平的比较。\n对于二进制分析部分，本文使用 IDA Pro；对于特征提取，则依赖于使用 IDA Pro api, Capstone 和 NetworkX 的一组 Python 脚本。本文在 Tensorflow 1.14 中实现了所有的神经网络模型，唯一的例外是 Trex，它是建立在 Fairseq 之上的，Fairseq 是 PyTorch 的序列建模工具包。最后，使用 Gensim 3.8 实现 Asm2Vec 并运行指令嵌入模型。\n采用统一的实现来最小化计算差异，并引入代码优化。当代码不可以时，本文联系了对应作者，但得到的支持和答复有限。Zeek 和 Asm2Vec 已经完全重现，但 CodeCMR 由于模型复杂等还在测试。\nDataset 本文创建了两个数据集 Dataset-1 和 Dataset-2，旨在捕捉现实世界软甲你得复杂和可变，同时涵盖了二元函数相似性的不同挑战：多个编译器和版本、多个编译优化选项、多个架构、不同位数以及不同性质的软件。使用 Dataset-1 训练模型，使用两个数据集进行测试评估。\nDataset-1 禁用函数内联。\nDataset-2 Dataset availability 作者发布了包括编译脚本和补丁在内的完整数据集。\nExperimental Settings 本文确定了六个不同的任务来进行评估：\nXO：函数对具有不同的优化，但是使用相同的编译器，版本与架构均相同 XC：函数对使用不同的编译器、版本以及优化，但是架构和位数相同 XC + XB：函数对使用不同的编译器、版本、优化及位数，但是架构相同 XA：函数对使用不同的架构、位数，但是使用相同的编译器、版本及优化 XA + XO：函数对使用不同的架构、位数以及优化，但是编译器和版本相同 XM：函数对来自任意的架构、位数、编译器、版本以及优化 前三个任务仅评估那些仅限于单一架构的用例的技术，包括功能相似性在恶意软件分析和协作逆向工程中的一些实际应用。第四个任务与使用始终相同的编译器和编译器选项交叉编译的固件图像的分析相关。第五个任务旨在支持 Dataset-2，该数据集仅使用一个编译器和编译器版本编译。最后，最后一个任务最具挑战性的，包括整个数据集的比较。在我们的评估中，我们还考虑了 XM 的三个子数据集：XM-S、XM-M 和 XM-L，其中包括小尺寸函数（少于 20 个基本块）、中等（在 20 到 100 之间）和大函数（超过 100 个块）。\nFuzzy-hashing Comparison Catalog1 使用原始字节作为输入特征和不同的签名大小（即哈希函数的数量）：本文展示了两个变体的结果，大小分别为 16 和 128。FunctionSimSearch （FSS）使用 graphlets（G）、mnemonics（M）和 directions（I）的组合：通过增量启用不同类型的输入特征（包括加权线性组合）来进行不同的测试。\n由于模糊哈希方法不受训练阶段的影响，因此我们使用它们来对每个编译变量如何影响二进制函数的比较进行有针对性的评估。因此，对于这些方法，我们首先执行多个实验，其中我们改变一个变量（即，编译器，版本，优化选项，体系结构和位），而保持其余的不变。表 1 中的结果清楚地表明，当一次只考虑一个自由变量时，即使是模糊哈希这样的简单方法也是有效的:“原始”字节被证实是相同架构比较的好特性，而 graphlet 在跨架构比较中是有效的。对于 Catalog1，签名大小越大，性能越好，但它们受到实现中包含的散列函数总数的限制。\n使用前面提到的六个任务对这两种方法进行评估。表 2 和表 4 显示了在两个 Dataset 上的结果：同时处理多个自由变量是个较难的问题，简单的方法无法奏效。在 XC 任务中（表 2），Catalog1 和 FSS 具有相同的 AUC。对于 FSS，仅 graphlets （G）配置在 XC 和 XO 以外的所有任务中都是最好的，其中使用带有助记符（G+M）的 graphlet 具有更高的 AUC。此外，FSS 在更大的函数上工作得更好，可能是由于可以提取的不同 graphlet 的数量更高。最后，在 XA 任务中，当使用助记符和即时等附加特征时，FSS 准确度会降低，但是，三个特征的加权线性组合不会产生比其他基本配置更好的结果。Catalog1 是这两种方法中最快的，而由于特征提取阶段较长，FSS 的速度大约慢 3 倍。\nMachine-learning Models Comparison 本文通过使用从 Dataset-1 中提取的公共训练数据集评估所选择的所有方法，并使用与 XM 任务相似的标准来创建正负样本。注意到在最通用数据上进行训练可以或者接近每个任务最佳的总体性能。\n比较机器学习模型，尤其是深度神经网络，是一项具有挑战性的任务，因为几个变量可能会影响最终结果，包括模型实现和配置（例如，层数或循环神经网络的类型）、不同的超参数（例如学习率和批量大小）、损失函数、优化器和训练时期的数量。本文中，所有的模型都使用相同随机生成的数据进行训练。作者进行了大量实验来评估不同的特征集、模型配置、超参数以及损失函数等。\n表 3 和表 4 显示了测试模型的结果及其在两个数据集上的相应变体。表 8 包括有关模型及其训练的一些通用信息，例如参数数量、批量大小、epoch 数和每个 epoch 的训练时间。\n结果表明，在产生函数向量表示（即 embedding）的模型中，GNN 在所有指标和所有任务中都达到了最佳值。注意到大多数机器学习模型在 AUC 上的表现非常相似，但在排名指标（MRR10 和 recall@1）上却有所不同，如图 2 所示。然后，对于其他 embedding 模型，SAFE 提供的 AUC 优于具有无监督特征的 GNN，并且在一个特定配置下的 AUC 略好于 Gemini。对于执行直接比较的方法，GMN 是所有任务中表现最好的模型，而 Zeek 的 AUC 略低（除了大型函数），但 MRR10 和 recall@1 要低得多。\nComparing Trex 在 XO 任务中，Trex 的 AUC 和与 Asm2Vec 相似的 MRR10 和 recall@1，以及其他 word2vec 变体，略低于 GNN 和 GMN 之一。与 Asm2Vec 不同，Trex 在 XA 和 XA+XO 任务中也保留了相同的性能，这表明了 Transformer 在（跨语言）跨架构设置中的强大功能。Trex 在 XO 任务 (0.94 vs. 0.90) 和 XA+XO 任务中提高了 SAFE 性能 (0.94 vs. 0.91)。在 GPU 上运行的 Trex 的推理比多进程 Asm2Vec 实现（100 个函数的 3.92 秒 vs. 8.51 秒）更快，但它比运行在 CPU 上的 SAFE 慢（100 个函数的 3.92 秒 vs. 1.46）。\nComparing different GNNs 都使用具有不同消息传递和聚合层的变体的 GNN。使用表 3 和表 4 中第三行和第四个行块的结果，我们使用基本块特征（操作码的单词包（BoW））和无特征来比较这两种变体。在所有任务中，Gemini 使用的 GNN (s2v) 提供了显着改进。然而，两种变体的执行时间仍然相似（在不使用特征时为 1.48 秒 vs. 1.40 秒）。\nComparing different feature set in GNN (s2v) Gemini 使用称为 Structure2vec (s2v) 的 GNN 模型，具有手动设计的特征。目标是了解这些特征对于根本不具有特征向量或使用另一组特征（例如操作码的单词包（BoW）的重要性。表 3 和表 4 中的结果表明，人工设计的特征仅在 XA 任务中的小函数和大函数上表现更好，并且操作码的 BoW 在所有不同的指标中都表现相似，甚至对不同的 K 值具有更好的召回率，如图 2 所示。此外，由于 Gemini 中的特征提取阶段较长，执行时间不同（1.66s vs. 7.18s）。这意味着更复杂和更难提取特征并不一定优于更基本的表示。200 个操作码的 BoW 具有 Gemini 特征数量的 20 倍，这导致 GNN 的节点神经网络的输入矩阵更大。我们还测试了 1024 个操作码的 BoW，但结果并没有显着提高，这意味着这些附加特征对函数的表示没有显着贡献。\n归一化的汇编上的指令 embedding 并不比操作码或手动设计的词袋具有更高的 AUC 和 MRR10，recall@1 也较低，训练时间却急剧增加。\nModelling functions using a textual encoder SAFE 使用基于指令嵌入的句子编码器，AUC 优于具有无监督特征的 GNN (s2v)。与 Gemini 相比，AUC 相似，但 MRR10 和 recall@1 较低。SAFE 在小函数上效果更好，当最大指令长度从 150 增加到 250 时，结果确实有所提高（表 3）。然而，SAFE 需要面对词汇外 (OOV) 词的挑战。InnerEye 或 Mirror 等其他方法应用不同的归一化汇编来缓解这个问题。为了说明这一挑战，我们测量了 OOV 指令在 SAFE 中的影响，我们观察到 x86-64 是 OOV 问题影响最大的架构（不到 30% 的函数没有 OOV 词），这可能是由于它的 CISC 指令集，然后是 MIPS，最后是 ARM，有超过 40% 的函数没有单个 OOV 词。\nAsm2Vec and other paragraph2vec models 表 3 和表 4 显示了 Asm2Vec 与 paragraph2vec 的 PV-DM 和 PV-DBOW 变体的比较结果。所有三个模型的性能相似，与 GNN 相比，使用特定的单架构方法并没有带来任何优势。注意到结果受到多种因素的影响，包括指令词汇表的大小、随机游走的数量以及几个实现细节。在训练期间，选择了最小频率为 5 的 1M 个标记（在 1.9M 中），其中大多数是数值偏移或十六进制地址。降低阈值确实改善了结果，但也增加了词汇量和训练时间。在推理时，没有更改词汇表，尽管这些无监督方法可以从新的推理词汇表中中受益，而不会使结果无效。在测试中，所有三个模型都共享相同的词汇表。还注意到，所有三种变体在只有一个变量自由的情况下都实现了高 AUC，例如表 4 中的 XO 任务，但当同时考虑多个编译变量时，AUC 会下降，例如表 3 中的 XC 任务，其中编译器、它的版本和优化更改。\nComparing efficiency 由于模型训练主要是一次性的努力，故而重点专注模型的推理时间效率。SAFE 在处理 100 个函数的机器学习模型中似乎最快。GMN 和 GNN 具有相似的运行时间和最低的运行时间，但是 GMN 仅在输入中处理一对函数。具有 Gemini 特征的 GNN (s2v) 比具有操作码特征的版本慢 4 倍：原因是更长的特征提取时间。Zeek 推理时间也受到长特征提取和处理时间的影响，在方法中是最慢的。由于额外的模型复杂性给出的推理时间较长，具有无监督特征的 GNN (s2v) 在 RNN 变体中速度较慢。同样，由于 NLP 模型的复杂性，Trex 受到较长的推理时间的影响。最后，Asm2Vec 是最慢的，因为它需要 10 个 epoch 的推理来提取新的函数嵌入。有趣的是，由于特定的指令嵌入构造，Asm2Vec 比其他 paragraph2vec 模型慢。\nCodeCMR/BinaryAI evaluation 如表 5 所示。使用 IDA 微码指令的 BoW 的 GNN 模型比使用操作码的 BoW 的 GNN 模型具有更高的 AUC，但第二个模型对于大K值具有更高的召回率（图 3）。一般来说，BinaryAI/CodeCMR 模型的所有指标都高于我们测试的其他模型。如果这些结果得到社区独立研究的验证，这可能是一个非常有前途的研究方向。\nNotes about Kim et al 在 Kim 等人在 Arxiv 上发表的论文中，作者提出了一种可解释的模型，并表明手动特征工程可以获得与“最先进的模型”相当的结果，即 Vulseeker。他们的评估一次只考虑一个变量变化（例如，只有编译器更改，而架构和优化级别是固定的）。与我们的六个评估任务相比，这是一个简化的设置，如表 1 所示，即使是简单的模糊散列方法也是有效的。但是，该论文缺乏对最先进技术的任何有意义的评估。\nVulnerability Discovery Use Case 本文在漏洞发现任务上测试了所有模型。在评估漏洞发现结果时，仅将特定固件映像的易受攻击函数用作查询。结果如表 7 所示：使用 MRR10 作为比较指标来评估每个模型如何为每个查询函数对目标脆弱函数进行排名。具有操作码特征的 GMN 模型是性能最好的模型，但它需要分析每对函数，从而限制了方法的可扩展性。Trex 和 Li 等人的 GNN 变体提供了第二好的结果。\n然而与 Netgear R7000 相比，具有自定义权重的 FSS 型号在 x64 比较中具有最高的 MRR10。本文使用了代码中附带的权重，这些权重已经针对 OpenSSL 的比较进行了优化。这证明 FSS 实现的优化过程具有实际用例，但它不能扩展到其他配置。表 7 还显示了不同体系结构之间的比较，特别是 Netgear 的 ARM32 列和 TP-Link 的 MIPS32 列显示了相同体系结构的比较。Netgear R7000 固件为 ARM 32 位编译，而 TP-Link Deco-M4 为 MIPS 32 位编译：这显示了 Asm2Vec 在相应列中具有高 MRR10 值的原因。最后，表 6 包含了 Netgear R7000 图像的脆弱函数的实际排名结果，可以看出在实践中较高的 MRR10 值可能隐藏着较低的排名。\nDiscussion 结果表明，一个机器学习模型，Li 等人的 GNN 在六个评估任务中优于所有其他变体，实现了类似于不太可扩展的 GMN 版本的性能。其他基于 embedding 的模型显示较低但相似的准确度。Zeek 是一种直接比较方法，在大函数上具有更高的 AUC。Asm2Vec 的表现并不比其他模型好，当多个编译变量同时变化时，模糊散列方法无效。\nWhich are the main contributions of the novel machinelearning solutions compared to simpler fuzzy hashing approaches? 深度学习模型提供了一种学习函数表示（即 embedding）的有效方法，强制在不同类型的函数之间进行空间分离。与模糊哈希方法不同，机器学习模型即使在多个编译变量同时发生变化时也能实现高精度，并且它们受益于构建在编译选项定义的可靠基础真理之上的大型训练数据集的优势。\nWhich is the role of different sets of features? 机器学习模型类型的选择，特别是 GNN 和损失函数的选择与输入中的特征同样重要。使用基本块特征（例如，ACFG）可以提供更好的结果，但是在精心手工设计的特征和更简单的特征（例如基本块操作码的单词包）之间存在很小的区别。指令内 embedding 并没有提高 GNN 模型的性能，但是本文认为需要进行广泛的测试来评估其他可能的组合。Zeek 展示了数据流信息如何提高结果，特别是对于大函数。最后，由于缺乏训练阶段，模糊哈希方法对特征类型更敏感。\nDo different approaches work better at different tasks? In particular, is the cross-architecture comparison more difficult than working with a single architecture? 本文的评估表明，大多数机器学习模型在所有评估任务上的表现非常相似，无论是在同一架构还是跨架构中。此外，没有必要在特定任务上训练它们，因为使用最通用的任务数据（XM）可以实现整体接近每个任务最佳的性能。模糊散列方法并非如此。然而，并非所有方法都可以在跨架构比较中使用。\nIs there any specific line of research that looks more promising as a future direction for designing new techniques? 结果表明，深度学习模型对于不同的函数相似度任务具有可扩展性和精度要求，特别是由于能够学习适合于多个任务的函数表示。虽然 GNN 模型提供了最好的结果，但还有几十种不同的变体需要测试。此外，GNN 与汇编指令编码器的结合是另一个有前途的方向。以前的许多工作都专注于他们选择不同的特征和特征抽象级别的努力，但最近的机器学习模型仅使用归一化汇编代码或中间表示，利用表示学习的力量。还必须研究组合中间表示和数据流信息的效果。此外，我们观察到特征和机器学习模型的选择并不是影响方法性能的唯一方面。过去几乎没有讨论其中一些互补方面。\nConclusion 本文进行了第一次系统研究，涵盖了处理二元函数相似性的五年多的研究工作。确定了研究领域的一些挑战，以及它们如何做出有意义的比较变得困难，如果不是完全不可能的话。我们的工作旨在弥合这一差距并帮助社区在该领域获得清晰度。希望通过发布我们所有的实现、数据集和原始结果，社区将有一个参考点来开始构建新方法，并将鼓励他们与一个共同的框架进行评估，以更好地辨别哪些新方面实际上正在提高技术水平，哪些方面似乎这样做。\nAcknowledgements references https://www.youtube.com/watch?v=e9bab7GpwnI\nhttps://blog.csdn.net/qq_33976344/article/details/130987005\nhttps://zhuanlan.zhihu.com/p/527154047\n",
  "wordCount" : "949",
  "inLanguage": "en",
  "image":"https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg","datePublished": "2024-03-25T00:00:00Z",
  "dateModified": "2024-03-25T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "lxmliu2002"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lxmliu2002.github.io/posts/paperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "lxmliu2002's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lxmliu2002.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lxmliu2002.github.io/" accesskey="h" title="lxmliu2002&#39;s Blog (Alt + H)">lxmliu2002&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lxmliu2002.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/" title="homepage">
                    <span>homepage</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lxmliu2002.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://lxmliu2002.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem
    </h1>
    <div class="post-description">
      PaperReading
    </div>
    <div class="post-meta"><span title='2024-03-25 00:00:00 +0000 UTC'>March 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;lxmliu2002&nbsp;|&nbsp;<a href="https://github.com/lxmliu2002/My_Blog/tree/master/content/posts/PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem.md" rel="noopener noreferrer" target="_blank">Any Suggestions?</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#how-machine-learning-is-solving-the-binary-function-similarity-problem" aria-label="How Machine Learning Is Solving the Binary Function Similarity Problem">How Machine Learning Is Solving the Binary Function Similarity Problem</a><ul>
                        
                <li>
                    <a href="#%e9%80%9a%e8%af%bb" aria-label="通读">通读</a><ul>
                        
                <li>
                    <a href="#abstract" aria-label="Abstract">Abstract</a></li>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a><ul>
                        
                <li>
                    <a href="#challenges" aria-label="Challenges">Challenges</a></li>
                <li>
                    <a href="#contributions" aria-label="Contributions">Contributions</a></li></ul>
                </li>
                <li>
                    <a href="#the-binary-function-similarity-problem" aria-label="The Binary Function Similarity Problem">The Binary Function Similarity Problem</a><ul>
                        
                <li>
                    <a href="#measuring-function-similarity" aria-label="Measuring Function Similarity">Measuring Function Similarity</a><ul>
                        
                <li>
                    <a href="#direct-vs-indirect-comparison" aria-label="Direct vs. indirect comparison">Direct vs. indirect comparison</a></li>
                <li>
                    <a href="#fuzzy-hashes-and-embeddings" aria-label="Fuzzy hashes and embeddings.">Fuzzy hashes and embeddings.</a></li>
                <li>
                    <a href="#code-embeddings" aria-label="Code embeddings">Code embeddings</a></li>
                <li>
                    <a href="#graph-embeddings" aria-label="Graph embeddings">Graph embeddings</a></li></ul>
                </li>
                <li>
                    <a href="#function-representations" aria-label="Function Representations">Function Representations</a><ul>
                        
                <li>
                    <a href="#raw-bytes" aria-label="Raw bytes">Raw bytes</a></li>
                <li>
                    <a href="#assembly" aria-label="Assembly">Assembly</a></li>
                <li>
                    <a href="#normalized-assembly" aria-label="Normalized assembly">Normalized assembly</a></li>
                <li>
                    <a href="#intermediate-representations" aria-label="Intermediate representations">Intermediate representations</a></li>
                <li>
                    <a href="#structure" aria-label="Structure">Structure</a></li>
                <li>
                    <a href="#data-flow-analysis" aria-label="Data flow analysis">Data flow analysis</a></li>
                <li>
                    <a href="#dynamic-analysis" aria-label="Dynamic analysis">Dynamic analysis</a></li>
                <li>
                    <a href="#symbolic-execution-and-analysis" aria-label="Symbolic execution and analysis">Symbolic execution and analysis</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#selected-approaches" aria-label="Selected Approaches">Selected Approaches</a><ul>
                        
                <li>
                    <a href="#selection-criteria" aria-label="Selection Criteria">Selection Criteria</a><ul>
                        
                <li>
                    <a href="#scalability-and-real-world-applicability" aria-label="Scalability and real-world applicability">Scalability and real-world applicability</a></li>
                <li>
                    <a href="#focus-on-representative-approaches-and-not-on-specific-papers" aria-label="Focus on representative approaches and not on specific papers">Focus on representative approaches and not on specific papers</a></li>
                <li>
                    <a href="#cover-different-communities" aria-label="Cover different communities">Cover different communities</a></li>
                <li>
                    <a href="#prioritize-latest-trends" aria-label="Prioritize latest trends">Prioritize latest trends</a></li></ul>
                </li>
                <li>
                    <a href="#selected-approaches-1" aria-label="Selected Approaches">Selected Approaches</a><ul>
                        
                <li>
                    <a href="#bytes-fuzzy-hashing-catalog1" aria-label="Bytes fuzzy hashing: Catalog1">Bytes fuzzy hashing: Catalog1</a></li>
                <li>
                    <a href="#cfg-fuzzy-hashing-functionsimsearch" aria-label="CFG fuzzy hashing: FunctionSimSearch">CFG fuzzy hashing: FunctionSimSearch</a></li>
                <li>
                    <a href="#attributed-cfg-and-gnn-gemini" aria-label="Attributed CFG and GNN: Gemini">Attributed CFG and GNN: Gemini</a></li>
                <li>
                    <a href="#attributed-cfg-gnn-and-gmn-li-et-al-2019" aria-label="Attributed CFG, GNN, and GMN: Li et al. 2019">Attributed CFG, GNN, and GMN: Li et al. 2019</a></li>
                <li>
                    <a href="#ir-data-flow-analysis-and-neural-network-zeek" aria-label="IR, data flow analysis and neural network: Zeek">IR, data flow analysis and neural network: Zeek</a></li>
                <li>
                    <a href="#assembly-code-embedding-asm2vec" aria-label="Assembly code embedding: Asm2Vec">Assembly code embedding: Asm2Vec</a></li>
                <li>
                    <a href="#assembly-code-embedding-and-self-attentive-encoder-safe" aria-label="Assembly code embedding and self-attentive encoder: SAFE">Assembly code embedding and self-attentive encoder: SAFE</a></li>
                <li>
                    <a href="#assembly-code-embedding-cfg-and-gnn-massarelli-et-al-2019" aria-label="Assembly code embedding, CFG and GNN: Massarelli et al., 2019">Assembly code embedding, CFG and GNN: Massarelli et al., 2019</a></li>
                <li>
                    <a href="#codecmrbinaryai" aria-label="CodeCMR/BinaryAI">CodeCMR/BinaryAI</a></li>
                <li>
                    <a href="#trex" aria-label="Trex">Trex</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#evaluation" aria-label="Evaluation">Evaluation</a><ul>
                        
                <li>
                    <a href="#implementation" aria-label="Implementation">Implementation</a></li>
                <li>
                    <a href="#dataset" aria-label="Dataset">Dataset</a><ul>
                        
                <li>
                    <a href="#dataset-1" aria-label="Dataset-1">Dataset-1</a></li>
                <li>
                    <a href="#dataset-2" aria-label="Dataset-2">Dataset-2</a></li>
                <li>
                    <a href="#dataset-availability" aria-label="Dataset availability">Dataset availability</a></li></ul>
                </li>
                <li>
                    <a href="#experimental-settings" aria-label="Experimental Settings">Experimental Settings</a></li>
                <li>
                    <a href="#fuzzy-hashing-comparison" aria-label="Fuzzy-hashing Comparison">Fuzzy-hashing Comparison</a></li>
                <li>
                    <a href="#machine-learning-models-comparison" aria-label="Machine-learning Models Comparison">Machine-learning Models Comparison</a><ul>
                        
                <li>
                    <a href="#comparing-trex" aria-label="Comparing Trex">Comparing Trex</a></li>
                <li>
                    <a href="#comparing-different-gnns" aria-label="Comparing different GNNs">Comparing different GNNs</a></li>
                <li>
                    <a href="#comparing-different-feature-set-in-gnn-s2v" aria-label="Comparing different feature set in GNN (s2v)">Comparing different feature set in GNN (s2v)</a></li>
                <li>
                    <a href="#modelling-functions-using-a-textual-encoder" aria-label="Modelling functions using a textual encoder">Modelling functions using a textual encoder</a></li>
                <li>
                    <a href="#asm2vec-and-other-paragraph2vec-models" aria-label="Asm2Vec and other paragraph2vec models">Asm2Vec and other paragraph2vec models</a></li>
                <li>
                    <a href="#comparing-efficiency" aria-label="Comparing efficiency">Comparing efficiency</a></li>
                <li>
                    <a href="#codecmrbinaryai-evaluation" aria-label="CodeCMR/BinaryAI evaluation">CodeCMR/BinaryAI evaluation</a></li>
                <li>
                    <a href="#notes-about-kim-et-al" aria-label="Notes about Kim et al">Notes about Kim et al</a></li></ul>
                </li>
                <li>
                    <a href="#vulnerability-discovery-use-case" aria-label="Vulnerability Discovery Use Case">Vulnerability Discovery Use Case</a></li></ul>
                </li>
                <li>
                    <a href="#discussion" aria-label="Discussion">Discussion</a><ul>
                        
                <li>
                    <a href="#which-are-the-main-contributions-of-the-novel-machinelearning-solutions-compared-to-simpler-fuzzy-hashing-approaches" aria-label="Which are the main contributions of the novel machinelearning solutions compared to simpler fuzzy hashing approaches?">Which are the main contributions of the novel machinelearning solutions compared to simpler fuzzy hashing approaches?</a></li>
                <li>
                    <a href="#which-is-the-role-of-different-sets-of-features" aria-label="Which is the role of different sets of features?">Which is the role of different sets of features?</a></li>
                <li>
                    <a href="#do-different-approaches-work-better-at-different-tasks-in-particular-is-the-cross-architecture-comparison-more-difficult-than-working-with-a-single-architecture" aria-label="Do different approaches work better at different tasks? In particular, is the cross-architecture comparison more difficult than working with a single architecture?">Do different approaches work better at different tasks? In particular, is the cross-architecture comparison more difficult than working with a single architecture?</a></li>
                <li>
                    <a href="#is-there-any-specific-line-of-research-that-looks-more-promising-as-a-future-direction-for-designing-new-techniques" aria-label="Is there any specific line of research that looks more promising as a future direction for designing new techniques?">Is there any specific line of research that looks more promising as a future direction for designing new techniques?</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#acknowledgements" aria-label="Acknowledgements">Acknowledgements</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="references">references</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="how-machine-learning-is-solving-the-binary-function-similarity-problem">How Machine Learning Is Solving the Binary Function Similarity Problem<a hidden class="anchor" aria-hidden="true" href="#how-machine-learning-is-solving-the-binary-function-similarity-problem">#</a></h1>
<h2 id="通读">通读<a hidden class="anchor" aria-hidden="true" href="#通读">#</a></h2>
<h3 id="abstract">Abstract<a hidden class="anchor" aria-hidden="true" href="#abstract">#</a></h3>
<p>精确计算两段二进制代码之间的相似度的能力在许多不同的问题中起着重要的作用。本文对该领域的最新技术进行评估研究。首先将其系统化，确定了代表三个不同社区新提出的解决方案。本文重新实现这些方案并使用不同编译器、优化选项和三种不同编译架构创建了一个新数据集。以此系统评估二进制相似度方法。</p>
<h3 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>二元函数相似度是指将一对函数的二进制表示作为输入，生成一个数值表示二者间的相似性。但是，不同的编译工具链、优化选项等，会使得简单的判定方法失效。</p>
<h4 id="challenges">Challenges<a hidden class="anchor" aria-hidden="true" href="#challenges">#</a></h4>
<p><strong>第一个挑战</strong>是目前既不能重现也不能复制以前的结果。由于重新实现以前的技术非常复杂且非常耗时，因此每个解决方案通常只与以前的几个技术进行比较，这些技术有时甚至不是为了解决相同的问题而设计的，并且在某些极端情况下，只与同一作者的先前论文进行比较。</p>
<p><strong>第二个挑战</strong>是评估结果往往是不透明的。不同的解决方案通常是针对略有不同的目标（搜索漏洞 vs. 发现类似的恶意软件样本)，在不同的设置（交叉编译器 vs. 交叉架构)，通过使用不同的相似性概念（相同的代码 vs. 相同的语义)，并在不同的粒度（代码片段 vs. 整个函数)操作。实验也在不同大小和性质的数据集上进行（firmware vs. 命令行实用程序)，并通过使用不同的指标（ROC 曲线 vs. top-n vs. MRR10)报告结果。因此每篇论文中的数值都无法直接比较。而且，不同的论文并不指明特定情景，且不说明其过滤掉细节、如何进行训练等，使得其难以再现。</p>
<p>不同的环境的可靠性实际上是如何影响性能是不得知的，即不清楚给定方法的优越结果是否与一些新的贡献有关。这两个挑战的综合影响导致形成了一个极其碎片化的领域，存在数十种技术，但没有明确了解哪种技术在哪种环境下有效（或无效）。这给我们带来了<strong>最后一个挑战</strong>：很难理解二进制相似性研究的方向。每个新的解决方案都采用了一种更复杂的技术，或者是多种技术的新组合，很难判断这是由更简单方法的实际限制驱动的，还是由需要说服审稿人相信每个工作的新颖性驱动的。这种碎片化通常会导致平行和不相交的研究方向，每个人都声称具有最佳的解决方案。这种碎片化也导致了评估和方法次优的论文。</p>
<h4 id="contributions">Contributions<a hidden class="anchor" aria-hidden="true" href="#contributions">#</a></h4>
<p>本文对该研究领域进行了一个系统评估。首先探索现有的研究，并根据所采用的方法对每个解决方案进行分组，特别关注最近基于机器学习的成功技术。然后选择、比较和实现十种最具代表性的方法及其可能的变体。这些方法代表了广泛的趋势，跨越了三个不同的研究社区：计算机安全，编程语言分析，以及机器学习社区。为了使得比较有意义，本文对实现建立在一个共同的框架之上。并利用并行编程和高效的编码技术避免对模型性能产生负面瓶颈。</p>
<p>通过重新实现各种方法（不一定是“论文”），本文分离出现有的“原语”，并在单独使用或相互结合使用时对它们进行评估，以获得见解并确定隐藏在先前作品复杂性中的重要因素，并回答各种开放的研究问题。为了使评估工作更具可比性，本文还提出了一个新的数据集，作为不同方面（如编译器系列、优化和体系结构)的通用基准。</p>
<blockquote>
<p>本文侧重于评估迄今为止提出的主要技术，而非重现论文报告中的准确数据。</p>
</blockquote>
<p>本文还发现了几个有趣的见解。例如，我们发现，虽然简单的方法（例如，模糊散列）在简单的设置中工作得很好，但在处理更复杂的场景时（例如跨架构数据集，或多个变量同时变化的数据集），它们就失败了。在机器学习模型中，基于图神经网络的模型在几乎所有任务中都取得了最好的结果，并且在比较推理时间时是最快的。另一个有趣的发现是，许多最近发表的论文在同一数据集上进行测试时都具有非常相似的准确性，尽管有几篇论文声称在技术水平上有所改进。</p>
<p>虽然我们不声称我们的代码或数据集比以前的作品更好或更有代表性，但我们发布了我们的模块化框架，重新实现了所有选定的方法，完整的数据集，以及如何重新创建和调整它的详细说明通过允许社区对单个组件进行实验并直接相互比较，我们希望鼓励和减轻未来对接近这一活跃研究领域感兴趣的研究人员的努力。</p>
<h3 id="the-binary-function-similarity-problem">The Binary Function Similarity Problem<a hidden class="anchor" aria-hidden="true" href="#the-binary-function-similarity-problem">#</a></h3>
<p>在其最简单的形式中，二进制函数相似性旨在计算一个数值，该数值捕获一对函数在其二进制表示中的“相似性”，即由编译器生成的构成函数体的原始字节（即机器代码)。请注意，在本文中，我们关注的是使用函数作为代码单元的方法，研究人员也研究了专注于低级抽象（例如，基本块)或高级抽象（例如，整个程序)的技术。根据我们的定义，两个“相似”函数可能具有截然不同的二进制表示——这就是这使得这个研究问题变得有趣且具有挑战性的原因。</p>
<p>二进制函数相似度已经在一百多篇论文中得到了研究。使情况更加复杂的是，大多数现有的方法不能映射到单一的技术类别，因为它们通常构建在不同的组件之上。在此，专注于这些方法组合的不同构建块，首先查看计算相似性的技术，然后查看这些方法可以利用的输入数据类型。</p>
<h4 id="measuring-function-similarity">Measuring Function Similarity<a hidden class="anchor" aria-hidden="true" href="#measuring-function-similarity">#</a></h4>
<h5 id="direct-vs-indirect-comparison">Direct vs. indirect comparison<a hidden class="anchor" aria-hidden="true" href="#direct-vs-indirect-comparison">#</a></h5>
<p>我们可以将测量函数相似性的技术分为两大类。<strong>第一类解决方案</strong>通过考虑原始输入数据或实现某种特征提取来实现函数对的直接比较。这些解决方案通常需要了解两个看似不相关的值可以表示相似的函数，反之亦然，接近的值不一定表示相似的东西。当从二进制函数中提取的特征不能通过使用基本相似性度量直接进行比较时，就会出现这种情况，因为它们可能没有在线性空间中表示，或者可能在相似性得分上没有等效的权重。因此，研究人员建议使用机器学习模型来确定两个函数是否相似，并给出一组提取的特征作为输入。有几种方法可以通过利用贝叶斯网络、卷积神经网络、图匹配网络（GMN）、规则前馈神经网络或它们的组合来实现这种类型的相似性。在这些情况下，该模型用于输出一对函数之间的相似性得分。</p>
<p>为了找到类似的函数，这些方法需要搜索整个数据集，并将查询函数的特征与数据集中的每个条目进行比较，这不是一个可扩展的解决方案。出于这个原因，许多方法实现了索引策略，通过诸如基于树的数据结构、局部敏感散列（近似最近邻搜索）、bloom 过滤器、基于更简单数据的自定义预过滤器、聚类技术，甚至分布式搜索方法（如 map-reduce）来预过滤潜在的相似候选。</p>
<p><strong>第二类解决方案</strong>实现了间接比较技术。这些方法将输入特征映射为“浓缩”的低维表示，可以使用距离度量（如欧几里得距离或余弦距离）轻松地相互比较。这些解决方案允许高效的一对多比较。例如，如果需要将一个新函数与整个数据集进行比较，可以首先将存储库中的每个函数映射到其各自的低维表示（这是一次性操作），然后对新函数执行相同的操作，最后通过使用近似最近邻等有效技术比较这些表示。</p>
<h5 id="fuzzy-hashes-and-embeddings">Fuzzy hashes and embeddings.<a hidden class="anchor" aria-hidden="true" href="#fuzzy-hashes-and-embeddings">#</a></h5>
<p>低维表示的一个流行的例子是模糊散列。模糊哈希是由与传统加密哈希不同的算法产生的，因为它们被有意设计为将类似的输入值映射到类似的哈希。结论是输入原始字节的微小变化会显著影响生成的散列。然而，即使普通模糊哈希可能不适合函数相似性，一些方法（如 FunctionSimSearch）已经提出了更专门的哈希技术来比较两个函数。</p>
<p>另一种流行的低维表示形式依赖于 embeddings。这个术语在机器学习社区中很流行，指的是一个低维空间，在这个空间中，语义上相似的输入被映射到彼此接近的点，而不管输入在其原始表示中看起来有多么不同。机器学习模型的目标是学习如何产生 embeddings，使相似函数之间的相似性最大化，并使不同函数之间的相似性最小化。在文献中，我们可以识别出两种主要类型的 embeddings：一种试图总结每个函数的代码，另一种试图总结它们的图结构。</p>
<h5 id="code-embeddings">Code embeddings<a hidden class="anchor" aria-hidden="true" href="#code-embeddings">#</a></h5>
<p>许多研究者试图利用现有的自然语言处理（NLP）技术，通过将汇编代码作为文本处理来解决二值函数相似问题。这些解决方案处理 token 流（例如，指令、助记符、操作数、规范化指令），每个代码块输出一个 embedding，每个指令输出一个 embedding，或者两者都输出。<strong>第一类方法</strong>（如 Asm2Vec）基于 word2vec，这是自然语言处理领域的一种知名技术。尽管这些模型不是为跨架构嵌入生成而设计的，但它们可以同时在不同的指令集上进行训练，学习不同语言的语法（但不能跨语言映射语义)，或者它们可以应用于中间语言之上。<strong>第二种解决方</strong>案基于 seq2seq 编码器 - 解码器模型，该模型允许将不同架构的语义映射到相同的 embedding 空间，从而学习跨架构的相似性。<strong>第三种类型</strong>的模型建立在 BERT 之上，这是基于 NLP 中最先进的预训练模型。例如，OrderMatters 使用在四个任务上预训练的 BERT 模型来生成基本的块 embedding，而 Trex 使用分层转换器和掩码语言建模任务来学习近似的程序执行语义，然后将学习到的知识转移到识别语义相似的函数。</p>
<p>汇编代码 embedding 通常受到它们可以处理的不同指令的数量（所谓的词汇表外问题（OOV））以及可以作为模型输入提供的最大指令数量的影响。因此，某些方法计算指令级 embedding，基本块 embedding 或函数级 embedding。指令或基本块 embedding 有时利用其他算法（如最长公共子序列）来计算函数相似性，或者它们被用作更复杂模型的一部分。</p>
<h5 id="graph-embeddings">Graph embeddings<a hidden class="anchor" aria-hidden="true" href="#graph-embeddings">#</a></h5>
<p>另一项研究建立在计算图嵌入的机器学习方法上。这些非常适合捕获基于函数控制流图的特性，本质上是跨架构的。这些嵌入可以通过自定义算法或更复杂的机器学习技术生成，例如图神经网络（GNN）。最近来自机器学习社区的一些方法提出了 GNN 的变体，例如图匹配网络（GMN）。这些变化能够在向量空间中产生可比较的嵌入，其特殊性在于这些嵌入对作为模型输入的两个图中的信息进行编码。</p>
<p>图嵌入方法还经常将每个基本块的信息编码到图的相应节点中，以增加表达性。例如，一些解决方案为每个节点计算一组属性，从而产生有属性控制流图（attributecontrolflow Graphs, ACFG），ACFG 可以手工设计，也可以以无监督的方式自动学习。其他作者利用前面讨论的一些技术利用其他嵌入计算层（例如，在基本块级别）。</p>
<h4 id="function-representations">Function Representations<a hidden class="anchor" aria-hidden="true" href="#function-representations">#</a></h4>
<p>二进制函数本质上是与特定于体系结构的机器码和数据相对应的字节流。从这个原始输入开始，研究人员使用了许多方法来提取更高级的信息，这些信息可以用来判断两个函数是否来自相同的源代码。该列表按抽象级别的增加排序，包括以下类别。</p>
<h5 id="raw-bytes">Raw bytes<a hidden class="anchor" aria-hidden="true" href="#raw-bytes">#</a></h5>
<p>一些解决方案直接使用原始二进制信息作为相似性度量的起点。</p>
<h5 id="assembly">Assembly<a hidden class="anchor" aria-hidden="true" href="#assembly">#</a></h5>
<p>汇编指令是由反汇编器获得的，当可以根据指令大小或操作数以多种不同的方式对操作进行编码时，汇编指令是有用的。</p>
<h5 id="normalized-assembly">Normalized assembly<a hidden class="anchor" aria-hidden="true" href="#normalized-assembly">#</a></h5>
<p>汇编代码通常对常量进行编码，导致操作数和操作数的潜在组合数量较多。使用归一化汇编指令抽象出部分可变性，减少词汇量，并将相同操作的所有可能变化聚合到单个表示中。</p>
<h5 id="intermediate-representations">Intermediate representations<a hidden class="anchor" aria-hidden="true" href="#intermediate-representations">#</a></h5>
<p>有些方法通过将二进制表示提升到中间表示（IR），在更高的抽象级别上工作。IR 的使用带来了几个优点：它可以统一语义等价但句法上不同的指令的表示；它可能会抽象出不同架构的非相关工件；它允许应用程序分析技术来简化（和收敛）某些代码结构。</p>
<h5 id="structure">Structure<a hidden class="anchor" aria-hidden="true" href="#structure">#</a></h5>
<p>许多方法试图捕捉给定函数的内部结构，或者函数在整个程序中扮演的角色。</p>
<h5 id="data-flow-analysis">Data flow analysis<a hidden class="anchor" aria-hidden="true" href="#data-flow-analysis">#</a></h5>
<p>在程序集级别的算术表达式的实现可以采用不同的形式来实现相同的语义。</p>
<h5 id="dynamic-analysis">Dynamic analysis<a hidden class="anchor" aria-hidden="true" href="#dynamic-analysis">#</a></h5>
<p>一些方法依赖于动态分析。</p>
<h5 id="symbolic-execution-and-analysis">Symbolic execution and analysis<a hidden class="anchor" aria-hidden="true" href="#symbolic-execution-and-analysis">#</a></h5>
<p>与具体的动态执行相反，一些方法依赖于符号执行来完全捕获分析下函数的行为，并在所有可能的路径下确定其输入与其输出之间的关系。</p>
<h3 id="selected-approaches">Selected Approaches<a hidden class="anchor" aria-hidden="true" href="#selected-approaches">#</a></h3>
<p>本文的主要贡献之一是位许多关键方法提供实现参考，并在公开和全面的数据集上进行实验来予以比较。理想情况下，人们会评估尽可能多的方法，但显然，重新实现它们是不可行的。同样重要的是要明白，虽然有数百篇关于该主题的论文，但其中许多都是相同技术的小变化，而新颖解决方案的数量明显较少。</p>
<h4 id="selection-criteria">Selection Criteria<a hidden class="anchor" aria-hidden="true" href="#selection-criteria">#</a></h4>
<h5 id="scalability-and-real-world-applicability">Scalability and real-world applicability<a hidden class="anchor" aria-hidden="true" href="#scalability-and-real-world-applicability">#</a></h5>
<p>我们对有可能扩展到大型数据集的方法感兴趣，这些方法可以应用于现实世界的用例。因此，我们不评估那些固有的缓慢且只关注直接比较的方法，例如基于动态分析、符号执行或高复杂性图相关算法的方法。</p>
<h5 id="focus-on-representative-approaches-and-not-on-specific-papers">Focus on representative approaches and not on specific papers<a hidden class="anchor" aria-hidden="true" href="#focus-on-representative-approaches-and-not-on-specific-papers">#</a></h5>
<p>有许多研究工作提出了相同方法的小变化，例如，通过重用以前的技术，同时稍微改变使用的特征。这通常会导致相似的总体精度，这使得它们在我们的比较中不那么有趣。</p>
<h5 id="cover-different-communities">Cover different communities<a hidden class="anchor" aria-hidden="true" href="#cover-different-communities">#</a></h5>
<p>对二值函数相似度问题的研究贡献来自不同的研究团体和学术界和工业界。本文希望概括来自多个社区的代表性研究，同时还考虑了行业提出的方法。</p>
<h5 id="prioritize-latest-trends">Prioritize latest trends<a hidden class="anchor" aria-hidden="true" href="#prioritize-latest-trends">#</a></h5>
<p>虽然这一研究领域的第一个贡献可以追溯到十多年前，但最近兴趣激增。本文综合考虑了各种类型的方法，在此基础上，优先考虑最新的研究。</p>
<h4 id="selected-approaches-1">Selected Approaches<a hidden class="anchor" aria-hidden="true" href="#selected-approaches-1">#</a></h4>
<p>根据分析，确定了 30 种技术，如图 1 所示，然后我们从中选择了 10 种具有代表性的解决方案用于我们的研究。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325161030521.png" alt="image-20240325161030521" style="zoom: 33%;" />
<p>左图显示了根据各自研究小组聚类的方法。这些团体来自学术界和工业界——谷歌和腾讯在这一领域都非常活跃。边线代表其他的解决方案，每篇论文将其结果与之比较。例如，Gemini 和 Genius 之间的箭头表示作者将 Gemini 的结果与 Genius 先前获得的结果进行了比较（两者来自同一组）。图 1 的右侧部分在 Y 轴上显示发布的时间轴，在 X 轴上显示不同类型的输入数据。然后根据计算相似度的不同方法将这些方法聚类为三大类，即模糊哈希、图嵌入和代码嵌入。</p>
<p>这两个图片都使用标签（括号中）来识别社区（[S] 安全性，[PL] 编程语言，[ML] 机器学习，以及 [SE] 软件工程）。我们还使用 [Mono] 和 [Cross] 标签来表示所提出的方法是否分别关注单架构或跨架构场景。</p>
<p>即使图 1 中的图表并不全面，只显示了我们选择的论文，它也再次描述了几篇论文如何仅与之前有限的一组方法进行比较。我们还可以从这些图中提取出其他有趣的信息。首先，在中间框中分组的二进制区分工具都是为直接比较两个二进制文件而设计的（例如，它们使用调用图），并且它们都是单一架构的。其次，图表显示，不同的社区往往是相当封闭的，他们很少与其他领域的论文进行比较。这是推进函数相似度研究的明显局限性，我们希望本文能够促进不同领域之间的合作。最后，我们可以找出一些开创性的论文，如 Gemini 和 discoverRE，这些论文在其他研究中被重新实施和广泛测试。这些工作显然激励了其他研究人员提高技术水平。</p>
<p>右边的时间轴图显示了一个明显的趋势：解决方案的复杂性和机器学习的使用随着时间的推移而增长。我们使用这些信息和图中描述的关系来选择 10 个最先进的解决方案，这些解决方案是可伸缩的、具有代表性的和最新的。与此同时，我们试图最大化研究团体之间的差异。</p>
<h5 id="bytes-fuzzy-hashing-catalog1">Bytes fuzzy hashing: Catalog1<a hidden class="anchor" aria-hidden="true" href="#bytes-fuzzy-hashing-catalog1">#</a></h5>
<p>Catalog1 是一种基于 MinHash 局部敏感哈希的模糊哈希方法。该算法以函数字节作为输入并产生固定长度的签名，这是比较来自同一架构的功能的一种有前途的方法。</p>
<h5 id="cfg-fuzzy-hashing-functionsimsearch">CFG fuzzy hashing: FunctionSimSearch<a hidden class="anchor" aria-hidden="true" href="#cfg-fuzzy-hashing-functionsimsearch">#</a></h5>
<p>FunctionSimSearch 使用 SimHash 算法计算模糊散列，该散列结合了从 CFG、助记符中提取的graphlet（即小连通、非同构、诱导子图）和来自汇编代码的直接值。</p>
<h5 id="attributed-cfg-and-gnn-gemini">Attributed CFG and GNN: Gemini<a hidden class="anchor" aria-hidden="true" href="#attributed-cfg-and-gnn-gemini">#</a></h5>
<p>Gemini 使用 GNN (Structure2vec) 从函数 ACFG（即具有基本块级别属性的控制流图）开始计算函数嵌入。这种方法标志着一个里程碑，因为它是第一个使用带有 Siamese 架构的 GNN 来学习函数相似性的人。</p>
<h5 id="attributed-cfg-gnn-and-gmn-li-et-al-2019">Attributed CFG, GNN, and GMN: Li et al. 2019<a hidden class="anchor" aria-hidden="true" href="#attributed-cfg-gnn-and-gmn-li-et-al-2019">#</a></h5>
<p>一种新颖的图匹配模型来计算图对之间的相似性。作者探索了函数相似性作为实际用例之一。</p>
<h5 id="ir-data-flow-analysis-and-neural-network-zeek">IR, data flow analysis and neural network: Zeek<a hidden class="anchor" aria-hidden="true" href="#ir-data-flow-analysis-and-neural-network-zeek">#</a></h5>
<p>Zeek 在基本块级别对提升代码（VEX IR）执行数据流分析（切片），并计算链。然后，训练一个两层全连接神经网络来学习跨架构相似性任务。这种方法是结合中间表示、数据流分析和机器学习的高级建议。</p>
<h5 id="assembly-code-embedding-asm2vec">Assembly code embedding: Asm2Vec<a hidden class="anchor" aria-hidden="true" href="#assembly-code-embedding-asm2vec">#</a></h5>
<p>Asm2Vec NLP 模型源自 paragraph2vec 的 PV-DM 变体，这是原始 word2vec 模型的扩展。Asm2Vec 引入了更精细的指令级拆分和嵌入构造，以克服具有装配指令的词汇外 (OOV) 问题的局限性。这种方法是完全无监督的，并在单架构实验中取得了最先进的结果。</p>
<h5 id="assembly-code-embedding-and-self-attentive-encoder-safe">Assembly code embedding and self-attentive encoder: SAFE<a hidden class="anchor" aria-hidden="true" href="#assembly-code-embedding-and-self-attentive-encoder-safe">#</a></h5>
<p>SAFE 使用自我注意句子编码器来学习跨体系结构函数嵌入。这种方法代表了来自 seq2seq 模型的 NLP 编码器，并且与 Asm2Vec 相比，它是专门为学习跨架构相似性而设计的。</p>
<h5 id="assembly-code-embedding-cfg-and-gnn-massarelli-et-al-2019">Assembly code embedding, CFG and GNN: Massarelli et al., 2019<a hidden class="anchor" aria-hidden="true" href="#assembly-code-embedding-cfg-and-gnn-massarelli-et-al-2019">#</a></h5>
<p>Mamasarelli 等人使用了 Gemini 相同的 Structure2vec GNN，但它改变了块级特征，从手动设计的特征切换到无监督特征。它是 Gemini 的演变，结合了指令级嵌入、基本块编码器和 GNN 的优点。</p>
<h5 id="codecmrbinaryai">CodeCMR/BinaryAI<a hidden class="anchor" aria-hidden="true" href="#codecmrbinaryai">#</a></h5>
<p>只关注以二进制格式处理函数的部分。该模型将中间表示与 NLP 编码器相结合以获得基本块嵌入和 GNN 以获得图嵌入。两个 LSTM 从函数中编码字符串和整数数据。函数嵌入是三个的串联，二进制模型是端到端训练的。</p>
<h5 id="trex">Trex<a hidden class="anchor" aria-hidden="true" href="#trex">#</a></h5>
<p>Trex 是最近基于分层 Transformer 和微跟踪的工作。本文提出了一种提取函数轨迹的动态组件，这是学习函数语义的基础。作者在这些轨迹上预训练 ML 模型，并转移学习到的知识以匹配语义相似的函数。匹配阶段完全基于静态特征，而模拟生成微跟踪只需要在预训练期间。这种跨架构解决方案建立在 Transformer 之上，Transformer 是 NLP 中最先进的深度学习模型。</p>
<h3 id="evaluation">Evaluation<a hidden class="anchor" aria-hidden="true" href="#evaluation">#</a></h3>
<h4 id="implementation">Implementation<a hidden class="anchor" aria-hidden="true" href="#implementation">#</a></h4>
<p>本文是为了在不同的方法之间进行相对公平的比较。基于此，作者以统一的方式完成了评估的各个阶段，包括二进制分析、特征提取和机器学习实现，创建一个共同点以对不同的方法进行有意义和公平的比较。</p>
<p>对于二进制分析部分，本文使用 IDA Pro；对于特征提取，则依赖于使用 IDA Pro api, Capstone 和 NetworkX 的一组 Python 脚本。本文在 Tensorflow 1.14 中实现了所有的神经网络模型，唯一的例外是 Trex，它是建立在 Fairseq 之上的，Fairseq 是 PyTorch 的序列建模工具包。最后，使用 Gensim 3.8 实现 Asm2Vec 并运行指令嵌入模型。</p>
<p>采用统一的实现来最小化计算差异，并引入代码优化。当代码不可以时，本文联系了对应作者，但得到的支持和答复有限。Zeek 和 Asm2Vec 已经完全重现，但 CodeCMR 由于模型复杂等还在测试。</p>
<h4 id="dataset">Dataset<a hidden class="anchor" aria-hidden="true" href="#dataset">#</a></h4>
<p>本文创建了两个数据集 Dataset-1 和 Dataset-2，旨在捕捉现实世界软甲你得复杂和可变，同时涵盖了二元函数相似性的不同挑战：多个编译器和版本、多个编译优化选项、多个架构、不同位数以及不同性质的软件。使用 Dataset-1  训练模型，使用两个数据集进行测试评估。</p>
<h5 id="dataset-1">Dataset-1<a hidden class="anchor" aria-hidden="true" href="#dataset-1">#</a></h5>
<p>禁用函数内联。</p>
<h5 id="dataset-2">Dataset-2<a hidden class="anchor" aria-hidden="true" href="#dataset-2">#</a></h5>
<h5 id="dataset-availability">Dataset availability<a hidden class="anchor" aria-hidden="true" href="#dataset-availability">#</a></h5>
<p>作者发布了包括编译脚本和补丁在内的完整数据集。</p>
<h4 id="experimental-settings">Experimental Settings<a hidden class="anchor" aria-hidden="true" href="#experimental-settings">#</a></h4>
<p>本文确定了六个不同的任务来进行评估：</p>
<ol>
<li>XO：函数对具有不同的优化，但是使用相同的编译器，版本与架构均相同</li>
<li>XC：函数对使用不同的编译器、版本以及优化，但是架构和位数相同</li>
<li>XC + XB：函数对使用不同的编译器、版本、优化及位数，但是架构相同</li>
<li>XA：函数对使用不同的架构、位数，但是使用相同的编译器、版本及优化</li>
<li>XA + XO：函数对使用不同的架构、位数以及优化，但是编译器和版本相同</li>
<li>XM：函数对来自任意的架构、位数、编译器、版本以及优化</li>
</ol>
<p>前三个任务仅评估那些仅限于单一架构的用例的技术，包括功能相似性在恶意软件分析和协作逆向工程中的一些实际应用。第四个任务与使用始终相同的编译器和编译器选项交叉编译的固件图像的分析相关。第五个任务旨在支持 Dataset-2，该数据集仅使用一个编译器和编译器版本编译。最后，最后一个任务最具挑战性的，包括整个数据集的比较。在我们的评估中，我们还考虑了 XM 的三个子数据集：XM-S、XM-M 和 XM-L，其中包括小尺寸函数（少于 20 个基本块）、中等（在 20 到 100 之间）和大函数（超过 100 个块）。</p>
<h4 id="fuzzy-hashing-comparison">Fuzzy-hashing Comparison<a hidden class="anchor" aria-hidden="true" href="#fuzzy-hashing-comparison">#</a></h4>
<p>Catalog1 使用原始字节作为输入特征和不同的签名大小（即哈希函数的数量）：本文展示了两个变体的结果，大小分别为 16 和 128。FunctionSimSearch （FSS）使用 graphlets（G）、mnemonics（M）和 directions（I）的组合：通过增量启用不同类型的输入特征（包括加权线性组合）来进行不同的测试。</p>
<p>由于模糊哈希方法不受训练阶段的影响，因此我们使用它们来对每个编译变量如何影响二进制函数的比较进行有针对性的评估。因此，对于这些方法，我们首先执行多个实验，其中我们改变一个变量（即，编译器，版本，优化选项，体系结构和位），而保持其余的不变。表 1 中的结果清楚地表明，当一次只考虑一个自由变量时，即使是模糊哈希这样的简单方法也是有效的:“原始”字节被证实是相同架构比较的好特性，而 graphlet 在跨架构比较中是有效的。对于 Catalog1，签名大小越大，性能越好，但它们受到实现中包含的散列函数总数的限制。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325205840655.png" alt="image-20240325205840655" style="zoom:50%;" />
<p>使用前面提到的六个任务对这两种方法进行评估。表 2 和表 4 显示了在两个 Dataset 上的结果：同时处理多个自由变量是个较难的问题，简单的方法无法奏效。在 XC 任务中（表 2），Catalog1 和 FSS 具有相同的 AUC。对于 FSS，仅 graphlets （G）配置在 XC 和 XO 以外的所有任务中都是最好的，其中使用带有助记符（G+M）的 graphlet 具有更高的 AUC。此外，FSS 在更大的函数上工作得更好，可能是由于可以提取的不同 graphlet 的数量更高。最后，在 XA 任务中，当使用助记符和即时等附加特征时，FSS 准确度会降低，但是，三个特征的加权线性组合不会产生比其他基本配置更好的结果。Catalog1 是这两种方法中最快的，而由于特征提取阶段较长，FSS 的速度大约慢 3 倍。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325210238734.png" alt="image-20240325210238734" style="zoom: 33%;" />
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325210846038.png" alt="image-20240325210846038" style="zoom:33%;" />
<h4 id="machine-learning-models-comparison">Machine-learning Models Comparison<a hidden class="anchor" aria-hidden="true" href="#machine-learning-models-comparison">#</a></h4>
<p>本文通过使用从 Dataset-1 中提取的公共训练数据集评估所选择的所有方法，并使用与 XM 任务相似的标准来创建正负样本。注意到在最通用数据上进行训练可以或者接近每个任务最佳的总体性能。</p>
<p>比较机器学习模型，尤其是深度神经网络，是一项具有挑战性的任务，因为几个变量可能会影响最终结果，包括模型实现和配置（例如，层数或循环神经网络的类型）、不同的超参数（例如学习率和批量大小）、损失函数、优化器和训练时期的数量。本文中，所有的模型都使用相同随机生成的数据进行训练。作者进行了大量实验来评估不同的特征集、模型配置、超参数以及损失函数等。</p>
<p>表 3 和表 4 显示了测试模型的结果及其在两个数据集上的相应变体。表 8 包括有关模型及其训练的一些通用信息，例如参数数量、批量大小、epoch 数和每个 epoch 的训练时间。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325211258114.png" alt="image-20240325211258114" style="zoom: 33%;" />
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325211325777.png" alt="image-20240325211325777" style="zoom:33%;" />
<p>结果表明，在产生函数向量表示（即 embedding）的模型中，GNN 在所有指标和所有任务中都达到了最佳值。注意到大多数机器学习模型在 AUC 上的表现非常相似，但在排名指标（MRR10 和 recall@1）上却有所不同，如图 2 所示。然后，对于其他 embedding 模型，SAFE 提供的 AUC 优于具有无监督特征的 GNN，并且在一个特定配置下的 AUC 略好于 Gemini。对于执行直接比较的方法，GMN 是所有任务中表现最好的模型，而 Zeek 的 AUC 略低（除了大型函数），但 MRR10 和 recall@1 要低得多。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325211600064.png" alt="image-20240325211600064" style="zoom:33%;" />
<h5 id="comparing-trex">Comparing Trex<a hidden class="anchor" aria-hidden="true" href="#comparing-trex">#</a></h5>
<p>在 XO 任务中，Trex 的 AUC 和与 Asm2Vec 相似的 MRR10 和 recall@1，以及其他 word2vec 变体，略低于 GNN 和 GMN 之一。与 Asm2Vec 不同，Trex 在 XA 和 XA+XO 任务中也保留了相同的性能，这表明了 Transformer 在（跨语言）跨架构设置中的强大功能。Trex 在 XO 任务 (0.94 vs. 0.90) 和 XA+XO 任务中提高了 SAFE 性能 (0.94 vs. 0.91)。在 GPU 上运行的 Trex 的推理比多进程 Asm2Vec 实现（100 个函数的 3.92 秒 vs. 8.51 秒）更快，但它比运行在 CPU 上的 SAFE 慢（100 个函数的 3.92 秒 vs. 1.46）。</p>
<h5 id="comparing-different-gnns">Comparing different GNNs<a hidden class="anchor" aria-hidden="true" href="#comparing-different-gnns">#</a></h5>
<p>都使用具有不同消息传递和聚合层的变体的 GNN。使用表 3 和表 4 中第三行和第四个行块的结果，我们使用基本块特征（操作码的单词包（BoW））和无特征来比较这两种变体。在所有任务中，Gemini 使用的 GNN (s2v) 提供了显着改进。然而，两种变体的执行时间仍然相似（在不使用特征时为 1.48 秒 vs. 1.40 秒）。</p>
<h5 id="comparing-different-feature-set-in-gnn-s2v">Comparing different feature set in GNN (s2v)<a hidden class="anchor" aria-hidden="true" href="#comparing-different-feature-set-in-gnn-s2v">#</a></h5>
<p>Gemini 使用称为 Structure2vec (s2v) 的 GNN 模型，具有手动设计的特征。目标是了解这些特征对于根本不具有特征向量或使用另一组特征（例如操作码的单词包（BoW）的重要性。表 3 和表 4 中的结果表明，人工设计的特征仅在 XA 任务中的小函数和大函数上表现更好，并且操作码的 BoW 在所有不同的指标中都表现相似，甚至对不同的 K 值具有更好的召回率，如图 2 所示。此外，由于 Gemini 中的特征提取阶段较长，执行时间不同（1.66s vs. 7.18s）。这意味着更复杂和更难提取特征并不一定优于更基本的表示。200 个操作码的 BoW 具有 Gemini 特征数量的 20 倍，这导致 GNN 的节点神经网络的输入矩阵更大。我们还测试了 1024 个操作码的 BoW，但结果并没有显着提高，这意味着这些附加特征对函数的表示没有显着贡献。</p>
<p>归一化的汇编上的指令 embedding 并不比操作码或手动设计的词袋具有更高的 AUC 和 MRR10，recall@1 也较低，训练时间却急剧增加。</p>
<h5 id="modelling-functions-using-a-textual-encoder">Modelling functions using a textual encoder<a hidden class="anchor" aria-hidden="true" href="#modelling-functions-using-a-textual-encoder">#</a></h5>
<p>SAFE 使用基于指令嵌入的句子编码器，AUC 优于具有无监督特征的 GNN (s2v)。与 Gemini 相比，AUC 相似，但 MRR10 和 recall@1 较低。SAFE 在小函数上效果更好，当最大指令长度从 150 增加到 250 时，结果确实有所提高（表 3）。然而，SAFE 需要面对词汇外 (OOV) 词的挑战。InnerEye 或 Mirror 等其他方法应用不同的归一化汇编来缓解这个问题。为了说明这一挑战，我们测量了 OOV 指令在 SAFE 中的影响，我们观察到 x86-64 是 OOV 问题影响最大的架构（不到 30% 的函数没有 OOV 词），这可能是由于它的 CISC 指令集，然后是 MIPS，最后是 ARM，有超过 40% 的函数没有单个 OOV 词。</p>
<h5 id="asm2vec-and-other-paragraph2vec-models">Asm2Vec and other paragraph2vec models<a hidden class="anchor" aria-hidden="true" href="#asm2vec-and-other-paragraph2vec-models">#</a></h5>
<p>表 3 和表 4 显示了 Asm2Vec 与 paragraph2vec 的 PV-DM 和 PV-DBOW 变体的比较结果。所有三个模型的性能相似，与 GNN 相比，使用特定的单架构方法并没有带来任何优势。注意到结果受到多种因素的影响，包括指令词汇表的大小、随机游走的数量以及几个实现细节。在训练期间，选择了最小频率为 5 的 1M 个标记（在 1.9M 中），其中大多数是数值偏移或十六进制地址。降低阈值确实改善了结果，但也增加了词汇量和训练时间。在推理时，没有更改词汇表，尽管这些无监督方法可以从新的推理词汇表中中受益，而不会使结果无效。在测试中，所有三个模型都共享相同的词汇表。还注意到，所有三种变体在只有一个变量自由的情况下都实现了高 AUC，例如表 4 中的 XO 任务，但当同时考虑多个编译变量时，AUC 会下降，例如表 3 中的 XC 任务，其中编译器、它的版本和优化更改。</p>
<h5 id="comparing-efficiency">Comparing efficiency<a hidden class="anchor" aria-hidden="true" href="#comparing-efficiency">#</a></h5>
<p>由于模型训练主要是一次性的努力，故而重点专注模型的推理时间效率。SAFE 在处理 100 个函数的机器学习模型中似乎最快。GMN 和 GNN 具有相似的运行时间和最低的运行时间，但是 GMN 仅在输入中处理一对函数。具有 Gemini 特征的 GNN (s2v) 比具有操作码特征的版本慢 4 倍：原因是更长的特征提取时间。Zeek 推理时间也受到长特征提取和处理时间的影响，在方法中是最慢的。由于额外的模型复杂性给出的推理时间较长，具有无监督特征的 GNN (s2v) 在 RNN 变体中速度较慢。同样，由于 NLP 模型的复杂性，Trex 受到较长的推理时间的影响。最后，Asm2Vec 是最慢的，因为它需要 10 个 epoch 的推理来提取新的函数嵌入。有趣的是，由于特定的指令嵌入构造，Asm2Vec 比其他 paragraph2vec 模型慢。</p>
<h5 id="codecmrbinaryai-evaluation">CodeCMR/BinaryAI evaluation<a hidden class="anchor" aria-hidden="true" href="#codecmrbinaryai-evaluation">#</a></h5>
<p>如表 5 所示。使用 IDA 微码指令的 BoW 的 GNN 模型比使用操作码的 BoW 的 GNN 模型具有更高的 AUC，但第二个模型对于大K值具有更高的召回率（图 3）。一般来说，BinaryAI/CodeCMR 模型的所有指标都高于我们测试的其他模型。如果这些结果得到社区独立研究的验证，这可能是一个非常有前途的研究方向。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325222231594.png" alt="image-20240325222231594" style="zoom:33%;" />
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325222603853.png" alt="image-20240325222603853" style="zoom:33%;" />
<h5 id="notes-about-kim-et-al">Notes about Kim et al<a hidden class="anchor" aria-hidden="true" href="#notes-about-kim-et-al">#</a></h5>
<p>在 Kim 等人在 Arxiv 上发表的论文中，作者提出了一种可解释的模型，并表明手动特征工程可以获得与“最先进的模型”相当的结果，即 Vulseeker。他们的评估一次只考虑一个变量变化（例如，只有编译器更改，而架构和优化级别是固定的）。与我们的六个评估任务相比，这是一个简化的设置，如表 1 所示，即使是简单的模糊散列方法也是有效的。但是，该论文缺乏对最先进技术的任何有意义的评估。</p>
<h4 id="vulnerability-discovery-use-case">Vulnerability Discovery Use Case<a hidden class="anchor" aria-hidden="true" href="#vulnerability-discovery-use-case">#</a></h4>
<p>本文在漏洞发现任务上测试了所有模型。在评估漏洞发现结果时，仅将特定固件映像的易受攻击函数用作查询。结果如表 7 所示：使用 MRR10 作为比较指标来评估每个模型如何为每个查询函数对目标脆弱函数进行排名。具有操作码特征的 GMN 模型是性能最好的模型，但它需要分析每对函数，从而限制了方法的可扩展性。Trex 和 Li 等人的 GNN 变体提供了第二好的结果。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325222630285.png" alt="image-20240325222630285" style="zoom:33%;" />
<p>然而与 Netgear R7000 相比，具有自定义权重的 FSS 型号在 x64 比较中具有最高的 MRR10。本文使用了代码中附带的权重，这些权重已经针对 OpenSSL 的比较进行了优化。这证明 FSS 实现的优化过程具有实际用例，但它不能扩展到其他配置。表 7 还显示了不同体系结构之间的比较，特别是 Netgear 的 ARM32 列和 TP-Link 的 MIPS32 列显示了相同体系结构的比较。Netgear R7000 固件为 ARM 32 位编译，而 TP-Link Deco-M4 为 MIPS 32 位编译：这显示了 Asm2Vec 在相应列中具有高 MRR10 值的原因。最后，表 6 包含了 Netgear R7000 图像的脆弱函数的实际排名结果，可以看出在实践中较高的 MRR10 值可能隐藏着较低的排名。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240325/image-20240325222914629.png" alt="image-20240325222914629" style="zoom:33%;" />
<h3 id="discussion">Discussion<a hidden class="anchor" aria-hidden="true" href="#discussion">#</a></h3>
<p>结果表明，一个机器学习模型，Li 等人的 GNN 在六个评估任务中优于所有其他变体，实现了类似于不太可扩展的 GMN 版本的性能。其他基于 embedding 的模型显示较低但相似的准确度。Zeek 是一种直接比较方法，在大函数上具有更高的 AUC。Asm2Vec 的表现并不比其他模型好，当多个编译变量同时变化时，模糊散列方法无效。</p>
<h4 id="which-are-the-main-contributions-of-the-novel-machinelearning-solutions-compared-to-simpler-fuzzy-hashing-approaches">Which are the main contributions of the novel machinelearning solutions compared to simpler fuzzy hashing approaches?<a hidden class="anchor" aria-hidden="true" href="#which-are-the-main-contributions-of-the-novel-machinelearning-solutions-compared-to-simpler-fuzzy-hashing-approaches">#</a></h4>
<p>深度学习模型提供了一种学习函数表示（即 embedding）的有效方法，强制在不同类型的函数之间进行空间分离。与模糊哈希方法不同，机器学习模型即使在多个编译变量同时发生变化时也能实现高精度，并且它们受益于构建在编译选项定义的可靠基础真理之上的大型训练数据集的优势。</p>
<h4 id="which-is-the-role-of-different-sets-of-features">Which is the role of different sets of features?<a hidden class="anchor" aria-hidden="true" href="#which-is-the-role-of-different-sets-of-features">#</a></h4>
<p>机器学习模型类型的选择，特别是 GNN 和损失函数的选择与输入中的特征同样重要。使用基本块特征（例如，ACFG）可以提供更好的结果，但是在精心手工设计的特征和更简单的特征（例如基本块操作码的单词包）之间存在很小的区别。指令内 embedding 并没有提高 GNN 模型的性能，但是本文认为需要进行广泛的测试来评估其他可能的组合。Zeek 展示了数据流信息如何提高结果，特别是对于大函数。最后，由于缺乏训练阶段，模糊哈希方法对特征类型更敏感。</p>
<h4 id="do-different-approaches-work-better-at-different-tasks-in-particular-is-the-cross-architecture-comparison-more-difficult-than-working-with-a-single-architecture">Do different approaches work better at different tasks? In particular, is the cross-architecture comparison more difficult than working with a single architecture?<a hidden class="anchor" aria-hidden="true" href="#do-different-approaches-work-better-at-different-tasks-in-particular-is-the-cross-architecture-comparison-more-difficult-than-working-with-a-single-architecture">#</a></h4>
<p>本文的评估表明，大多数机器学习模型在所有评估任务上的表现非常相似，无论是在同一架构还是跨架构中。此外，没有必要在特定任务上训练它们，因为使用最通用的任务数据（XM）可以实现整体接近每个任务最佳的性能。模糊散列方法并非如此。然而，并非所有方法都可以在跨架构比较中使用。</p>
<h4 id="is-there-any-specific-line-of-research-that-looks-more-promising-as-a-future-direction-for-designing-new-techniques">Is there any specific line of research that looks more promising as a future direction for designing new techniques?<a hidden class="anchor" aria-hidden="true" href="#is-there-any-specific-line-of-research-that-looks-more-promising-as-a-future-direction-for-designing-new-techniques">#</a></h4>
<p>结果表明，深度学习模型对于不同的函数相似度任务具有可扩展性和精度要求，特别是由于能够学习适合于多个任务的函数表示。虽然 GNN 模型提供了最好的结果，但还有几十种不同的变体需要测试。此外，GNN 与汇编指令编码器的结合是另一个有前途的方向。以前的许多工作都专注于他们选择不同的特征和特征抽象级别的努力，但最近的机器学习模型仅使用归一化汇编代码或中间表示，利用表示学习的力量。还必须研究组合中间表示和数据流信息的效果。此外，我们观察到特征和机器学习模型的选择并不是影响方法性能的唯一方面。过去几乎没有讨论其中一些互补方面。</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>本文进行了第一次系统研究，涵盖了处理二元函数相似性的五年多的研究工作。确定了研究领域的一些挑战，以及它们如何做出有意义的比较变得困难，如果不是完全不可能的话。我们的工作旨在弥合这一差距并帮助社区在该领域获得清晰度。希望通过发布我们所有的实现、数据集和原始结果，社区将有一个参考点来开始构建新方法，并将鼓励他们与一个共同的框架进行评估，以更好地辨别哪些新方面实际上正在提高技术水平，哪些方面似乎这样做。</p>
<h3 id="acknowledgements">Acknowledgements<a hidden class="anchor" aria-hidden="true" href="#acknowledgements">#</a></h3>
<h2 id="references">references<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p><a href="https://www.youtube.com/watch?v=e9bab7GpwnI">https://www.youtube.com/watch?v=e9bab7GpwnI</a></p>
<p><a href="https://blog.csdn.net/qq_33976344/article/details/130987005">https://blog.csdn.net/qq_33976344/article/details/130987005</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/527154047?utm_id=0">https://zhuanlan.zhihu.com/p/527154047</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lxmliu2002.github.io/tags/binary-code-search/">Binary-Code-Search</a></li>
      <li><a href="https://lxmliu2002.github.io/tags/vulnerability-search/">Vulnerability-Search</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lxmliu2002.github.io/posts/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0_d1/">
    <span class="title">« Prev</span>
    <br>
    <span>联邦学习_d1</span>
  </a>
  <a class="next" href="https://lxmliu2002.github.io/posts/paperreading_jtrans/">
    <span class="title">Next »</span>
    <br>
    <span>PaperReading_jTrans</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on x"
            href="https://x.com/intent/tweet/?text=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem&amp;url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f&amp;hashtags=Binary-Code-Search%2cVulnerability-Search">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f&amp;title=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem&amp;summary=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem&amp;source=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f&title=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on whatsapp"
            href="https://api.whatsapp.com/send?text=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem%20-%20https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on telegram"
            href="https://telegram.me/share/url?text=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem&amp;url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem&u=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/lxmliu2002">lxmliu2002</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
