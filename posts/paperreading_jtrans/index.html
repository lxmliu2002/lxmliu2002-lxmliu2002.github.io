<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PaperReading_jTrans | lxmliu2002&#39;s Blog</title>
<meta name="keywords" content="Binary-Code-Search, Vulnerability-Search">
<meta name="description" content="PaperReading">
<meta name="author" content="lxmliu2002">
<link rel="canonical" href="https://lxmliu2002.github.io/posts/paperreading_jtrans/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lxmliu2002.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lxmliu2002.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lxmliu2002.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lxmliu2002.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lxmliu2002.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lxmliu2002.github.io/posts/paperreading_jtrans/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://lxmliu2002.github.io/posts/paperreading_jtrans/">
  <meta property="og:site_name" content="lxmliu2002&#39;s Blog">
  <meta property="og:title" content="PaperReading_jTrans">
  <meta property="og:description" content="PaperReading">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-03-24T00:00:00+00:00">
    <meta property="article:tag" content="Binary-Code-Search">
    <meta property="article:tag" content="Vulnerability-Search">
    <meta property="og:image" content="https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg">
<meta name="twitter:title" content="PaperReading_jTrans">
<meta name="twitter:description" content="PaperReading">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lxmliu2002.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PaperReading_jTrans",
      "item": "https://lxmliu2002.github.io/posts/paperreading_jtrans/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PaperReading_jTrans",
  "name": "PaperReading_jTrans",
  "description": "PaperReading",
  "keywords": [
    "Binary-Code-Search", "Vulnerability-Search"
  ],
  "articleBody": "jTrans: Jump-Aware Transformer for Binary Code Similarity Detection 通读 ABSTRACT 二进制代码相似性检测（Binary code similarity detection，BCSD）在漏洞分析、软件构建分析和逆向工程等领域有着重要应用。现有的工作表明深度神经网络（DNNs）可以理解二进制代码的指令或者是控制流图，并支持 BCSD。本文中，作者提出了一个新的基于 transformer 的方法 jTrans，来学习二进制代码的表示。这是第一个将二进制代码的控制流信息嵌入到基于 transformer 的语言模型中的解决方案，通过使用所分析的二进制代码的新的跳跃感知表示和新设计的预训练任务。\nINTRODUCTION Binary code similarity detection(BCSD)可以识别两个二进制代码片段之间的相似程度，这有着广泛的应用，包括已知的漏洞发现，恶意软件检测和聚类，软件剽窃检测，补丁分析，以及软件供应链分析。\n在机器学习应用到该领域之前，传统的 BCSD 严重依赖于手工提取的 CFG 特征，它可以捕获句法知识，如 bindiff 采用图同构技术来计算两个函数的 CFG 之间的相似性，但这种相似性可能会根据编译器的优化而改变，而注入 bingo 等方案通过计算 CFG 片段的相似性来实现对 CFG 变化的更大稳健性。这些手工特征很难捕捉到二进制代码的精确语义，因此仅具备较低的准确性。\n一般来讲，这些解决方案是将目标二进制代码嵌入到向量中，并计算函数在向量空间的相似度。一些解决方案，如 Asm2Vec 和 SAFE，使用受自然语言处理（NLP）启发的语言模型来建模汇编语言(机器代码)。其他研究使用图神经网络 (GNNs) 来学习 CFGs 的表示并计算它们的相似性。一些研究结合了这两种方法，通过 NLP 技术学习基本块的表示，并通过 GNN 进一步处理CFG中的基本块特征。尽管性能有所提高，但现有方法有一些局限性。\n首先，基于 NLP 的汇编语言建模只考虑了指令的顺序以及它们之间的关系；没有考虑有关程序实际执行（例如控制流）的信息。因此，仅依靠 NLP 的方法将缺乏对分析二进制文件的语义理解，而且也不能很好的适应代码中可能出现的重大变化，这些变化是编译器所带来的结果。\n其次，仅依靠 CFG 会错过每个基本块中指令的语义。使用 GNN 来处理 CFG 只能捕获结构信息，且难以并行训练和使用。\n第三，现有的解决方案的数据集不够大，不够多样化，缺乏一个通用的基准。\n在本文中，提出了 jTrans，一种新颖的基于 Transformer 的模型，旨在解决上述问题并支持现实世界的二进制相似性检测。我们将捕获指令语义的 NLP 模型与捕获控制流信息的 CFG 相结合，以推断二进制代码的表示。将控制流信息融合到 Transformer 架构中\n作者通过为每个跳转指令目标共享 token embeddings 和 position embeddings 之间的参数来修改 Transformer 以捕获控制流信息。首先使用无监督学习任务预训练 jTrans，来学习二元函数指令的语义和控制流信息。接着对预训练的 jTrans 进行微调，来匹配语义相似的函数。\n除此之外，还提出了一个庞大而多元化的数据集 BinaryCorp。新创建的数据集能够减轻现有数据集的过拟合和缺乏多样性问题。\n本文实现了 jTrans，并在真实的 BCSD 问题上进行了评估验证。\n提出了一个新颖的基于跳跃感知的 Transformer 的模型 jTrans 创建了一个数据集 BinaryCorp 进行了广泛实验进行验证 PROBLEM DEFINITION BCSD 是一个计算二元函数相似度的基本任务，可用于以下 3 种情况：\n一对一，返回一个源函数与目标函数的相似度分数 一对多，返回目标函数与函数池中所有函数的相似度分数 多对多，根据相似度将函数池分为若干组 本文主要研究一对多问题。\n下图所示了一个二进制函数的例子，左边是线性的汇编指令，右边是 CFG 控制流图；\nBCSD 的目标是开发一个解决方案来计算两个函数之间的相似度分数，其中两个函数由两个相同或相似的源代码函数编译。\nRelated Works Non-ML-based BCSD Approaches 机器学习之前，传统的 BCSD 包括静态技术和动态方法。在逻辑上相似的代码具有相似的运行行为的假设前提下，动态分析通过分析手工制作的动态特征来衡量二进制代码相似度。然而，由于基本块拆分，无法用于不同编译器优化的情况等。这些动态方法的主要缺点是不适合大规模二进制代码相似度检测。\n而 BCSD 的静态方法是基于是识别二进制代码中的结构差异。静态方法比动态方法有效，但由于其只捕获二进制的结构和句法信息，忽略指令之间的语义关系导致精度较低。\nrning-based BCSD Approaches 基于学习的 BCSD 的研究受到自然语言处理 (NLP) 的最新发展的启发，它使用称为嵌入的实值向量来编码单词和句子的语义信息。如图，使用深度学习算法使逻辑上相似的二元函数的向量距离更接近。\n在 BCSD 领域也探索了无监督学习。\n基于学习的方法适用于大规模二进制代码相似度检测，因为二进制代码函数可以转化为向量。然后使用向量距离计算相似度，计算效率很高。但是或多或少都存在一些问题，如忽略指令和基本块的语义、忽略结构信息、忽略指令之间的关系等。\nMETHODOLOGY Overview jTransis 基于 Transformer-Encoder 架构，用于自动学习二进制程序的指令语义和控制流信息，由几个重要的变化组成，旨在使其对二进制分析的挑战性领域更有效。\n首先对输入二进制汇编代码进行预处理，使其包含程序的跳转关系，即控制流信息。修改 Transformer 的单个输入 token 的 embedding，使得跳转的起点和终点位置在语义上相似。 鉴于自然语言和程序在数据流方面的相似性，本文选择使用 MLM 的 Transformer 训练方法。Masked language model(MLM) 要求根据邻居的内容来预测屏蔽的标记内容，从而迫使模型对指令之间的关系形成上下文理解。增加辅助训练任务，要求模型理解跳转指令的目标。 此外，为了鼓励模型学习跳转合并到代码中的方式，我们提出了一种新颖的辅助训练任务，该任务要求模型预测跳转指令的目标。我们称之为 Jump Target Prediction (JTP) 的任务需要对代码的语义进行深入的理解。\nBinary Function Representation Model jTrans 基于 BERT 架构，使用 BERT 使用的相同方法对文本进行建模，但是二进制代码与自然语言有许多不同，如二进制代码的词汇表；二进制代码的跳转指令。\n要应用 BERT，必须解决两个问题。\n词汇外的 token。jTrans 只能在固定词汇表上进行训练，不在上面的需要以一种使 Transformer 能够有效地处理的方式表示。 对 jump 指令建模。预处理后，源 token 与目标 token 之间的有效信息所剩极少，BERT 很难推断它们之间的关联关系，这使得上下文推断更加困难。 Preprocessing instructions 为了缓解 OOV 问题，本文使用 IDA 分析输入的二进制程序并生成汇编指令序列，然后使用如下标记化策略来规范和减少词汇量：\n使用操作码和操作数作为 token 使用代替字符串 使用代替常量值 外部函数调用保留，内部函数调用进行替换 对于跳转对，使用 JUMP_XXX 进行替换 Modeling jump instructions 本文使用位置编码使得模型能够确定 token 之间的距离，并且修改位置编码机制以反映 JUMP 指令的效果，通过参数共享使其具有很强的上下文联系。\n本文只关注直接跳转指令，间接跳转识别是一个公开挑战，目前还无法处理。\nThe Rationale of Our Proposed Approach 通过共享参数，在表示中创建了高度的相似性。当 jTrans 为其分配高注意力权重时，将自动为其伙伴分配高注意力，确保跳转指令的两个部分以及其附近的指令能够包括其中。\nPre-training jTrans jTrans 所基于的 BERT 架构使用两个无监督学习任务进行预训练。第一个任务是掩码语言模型 (MLM)， BERT 的任务是重建随机掩码标记。第二个无监督学习任务旨在通过判断两个句子是否连续来磨练 BERT 的上下文能力。建立在 BERT 的整体训练过程的基础上，同时进行特定领域的适应：保留 MLM 任务，但用称为跳转目标预测 (JTP) 的任务取代第二个任务。\nThe Masked Language Model Task jTrans 使用 BERT 的掩码过程：我们随机选择的 80% 的标记被掩码标记替换（表明它们需要重建），10% 被其他随机标记替换，10% 保持不变。\nMLM 的例子如下。为了成功，我们的模型必须学习基本的组装语法及其上下文信息。例如，成功重建 rdi 令牌需要模型学习函数的调用约定，而 rsp 令牌需要了解连续执行。\nJump Target Prediction JTP 任务定义如下: 给定一个随机选择的跳转源 token，模型被要求去预测相应的目标 token。这项任务，即使对人类专家来说也是困难的，需要我们的模型对 CFG 有深刻的理解。这反过来又提升了 jTrans 的性能。JTP 的实现首先从可用的跳转源 token 中随机选择一个子集。然后将这些标记替换为标记 。\nJTP 的例子如下。将 JUMP_20 替换成 ，模型的任务是预测索引。该训练任务提高了jTrans学习分析函数的控制流的能力。\njTrans 在预训练阶段的整体损失函数是 MLM 和 JTP 目标函数的总和：\nFine-tuning for Binary Similarity Detection 为了使相同的函数对距离最小，使不相同的函数对距离最大，通过对比学习的目标函数微调训练。目标函数如下：\nLarge-Scale Dataset Construction 我们基于 ArchLinux 官方存储库和 Arch User Repository 构建了用于二进制相似性检测的数据集。\nProjects Filtering 使用 C 或 C++ 项目构建数据集，其他的予以删除。\nCompilation pipeline 将环境变量指定为 gcc、g++、clang、clang++ 的自修改版本。修改后的编译器更改与优化级别相关的命令行参数，以预期编译参数。此外，它将预期的编译参数附加到原始参数。我们使用这两种方法来确保编译是使用预期的优化级别完成的。\nLabel Collection 需要首先获得未剥离的二进制并获得函数的偏移量。用修改后的版本替换了 strip。无论传递的参数如何，它不会剥离符号表。\nEXPERIMENTAL SETUP The BinaryCorp Dataset BinaryCorp 由自动编译管道产生的大量二进制文件组成。数据集的统计数据如图所示。\nBaselines 使用 jTrans 与六个表现最佳的 baseline 进行比较：\nGenius，非深度学习方法。以属性控制流图的形式提取原始特征，并使用位置敏感散列 (LSH) 生成数字向量以进行漏洞搜索。 Gemini，为每个基本块提取手工制作的特征，并使用 GNN 来学习分析函数的 CFG 表示。 SAFE，使用具有注意力机制的 RNN 架构来生成分析函数的表示，它接收汇编指令作为输入。 Asm2Vec，使用 CFG 上的随机游走对指令序列进行采样，然后使用 PV-DM 模型联合学习函数和指令标记的嵌入。 GraphEmb，使用 word2vec 来学习指令 token 的 embedding。接下来，它使用 RNN 为每个基本块生成独立的 embedding，最后使用 structure2vec 来组合嵌入并生成分析函数的表示。 OrderMatters，该方法结合了两种类型的 embedding。第一个 embedding 类型使用 BERT 为每个基本块创建一个 embedding，然后使用 GNN 组合所有这些 embedding 以生成最终表示。第二种 embedding 是通过在 CFG 上应用 CNN 获得的。然后将这两个 embedding 连接起来。 Evaluation Metrics EVALUATION Biniary Similarity Detection Performance 本文对这两个数据集进行评估，BinaryCorp-3M 和 BinaryCorp-26M，使用两个函数池大小 32 和 10,000，以便 jTrans 和 baseline 可以以不同程度的难度进行评估。实验结果如下所示，jTrans 极大优于其他模型。对于 poolsize=32 （表 2 和 4），jTrans 在 MRR 指标上比最接近的基准竞争对手高出 0.07，在 recall@1 指标上高出 10% 以上。当我们在较大的池规模（10000）上评估模型时，性能上的差异变得更加明显。对于这种设置，其结果如表 3 和表 5 所示，jTrans 在 MRR 指标上比最接近的竞争对手高出 0.26，在 recall@1 指标上高出 27%。\nThe Effects of Poolsize on Performance 现在深入分析池大小对二进制分析 SOTA 方法性能的影响。结果如图所示。对不同的池大小 (2、10、32、128、512、1000 和 10000) 进行了多次实验，并绘制了各种优化对的结果。结果表明，随着池大小的增加，所有 baseline 的相对性能都比 jTrans 差。要指出的是，对于非常小的池大小（例如 2），SOTA baseline（如 SAFE 和 Asm2Vec）的性能几乎与 jTrans 相同，后者的性能比 jTrans 高出约 2%。在小池上评估二进制分析工具并不能为它们在现实世界中的性能提供有意义的指示。\nReal-World Vulnerability Search 将 jTrans 应用于一个已知的漏洞数据集，目的是搜索有漏洞的函数。下图显示了每个查询的 recall@10 度量的结果。将所提出方法与来自 SAFE 和 Asm2Vec 的两个主要基线进行了比较。例如，在包含 3038 个函数的 openjpeg 项目中的 CVE-2016-3183 上，所提出方法实现了 100% 的 top-10 召回率，这意味着它成功地检索了所有 10 个变体，而 Asm2Vec 和 SAFE 分别实现了 recall@10 值的 36.9% 和 28.6%。实验结果表明，jTrans 能够在大池规模上表现良好，因此可以在现实场景中有效部署作为漏洞搜索工具。\nThe Impact of Our Jump-aware Design 测试跳变感知设计极大地提高了 jTrans 分析二进制代码 CFG 的能力。本文训练了一个标准的 BERT 模型，该模型不使用我们对跳转信息的表示，并将其与我们的方法进行比较。与 SAFE 类似，标准 BERT 不接收控制流信息，只能从汇编序列信息中学习。使用 Recall@1 评估了 BinaryCorp- 3M 上的标准 BERT 模型和 jTrans, poolsize=10,000。我们的评估结果如图所示。结果表明，标准 BERT 的性能明显低于 jTrans，因为它在每个优化对上的性能都较低。平均而言，jTrans 比 BERT 高出 7.3%。这些结果清楚地表明，在汇编语言序列建模中加入控制流信息对我们的模型是非常有益的。\n为了进一步探索该设计的有效性，本文分析的预训练模型预测二进制代码中掩码跳跃地址的能力。在 BinaryCorp-3M 上进行了实验。对于评估集中的每个函数，我们随机抽取一些概率为 15% 的跳跃位置，并用函数中的 替换它们。然后，我们分析了模型正确预测每个掩码跳转目标的跳转目标位置的概率。如表所示，表明 jTrans 能够预测跳跃位置。我们的预训练模型可以预测跳跃指令的目标，top-1 准确率为 92.9%，top-10 准确率为 99.5%。这种准确性非常高，特别是对于 top-1，因为有 512 个可能的跳跃位置。这些结果表明我们的预训练模型能够成功捕获二进制的上下文指令信息。\nEvaluating the Efficacy of Pre-training 和最初的 BERT 一样，预训练是我们模型的关键组成部分。它的主要优点是可以在未标记的数据上执行，这更容易获得大量的数据。为了评估预训练方法(MLM和JTP)的有效性，我们评估了不进行任何微调的模型版本。遵循与零样本学习相同的方法，在预训练阶段使用没有标签信息的二进制文件。然后，在不微调预训练模型的情况下，立即将其应用于二进制相似性搜索任务。该模型的计算结果记为 jTrans-zero，如表 2-5 所示。可以看到，集市没有微调，jTrans-zero 也优于 poolsize=10000 的所有 baseline。\nDISCUSSION 现有的基于深度学习的作品，以及 jTrans，将单个二元函数嵌入到数值向量中，并比较向量之间的相似性。因此，它们的准确性随着池大小而下降。如图 6 所示，如果池大小为 10,000，大多数现有解决方案的准确率下降到 20% 以下。在现实世界中，池的大小会大得多。直接将两个二元函数作为输入的模型可以更好地捕获函数间关系，进一步提高 BCSD 的性能，即使在大池中。然而，训练一个模型直接比较两个函数会有更高的开销。我们将在现实世界 BCSD 任务中使用 jTrans 作为未来工作时平衡准确性和开销。\nCONCLUSION 在这项工作中，我们提出了 jTrans，这是第一个将控制流信息嵌入到基于 Transformer 的语言模型的解决方案。我们的方法利用了一种新颖的跳跃感知架构设计，不依赖于 GNN 的使用。实验结果表明，我们的方法在 BCSD 任务上始终优于最先进的方法。通过密集评估，我们还发现了对当前 SOTA 方法评估的弱点。此外，我们向社区展示和发布一个名为 BinaryCorp 的新创建的数据集。我们的数据集迄今为止包含最多的多样化二进制文件，我们相信它可以用作该领域未来研究的高质量基准。\nreferences https://blog.csdn.net/AcSuccess/article/details/127161840\nhttps://blog.csdn.net/qq_33976344/article/details/130782176\nhttps://www.youtube.com/watch?v=rAirmnUsC1k\nhttps://mp.weixin.qq.com/s/xvKRGY6Vbaj_XHys7kqz2A\n",
  "wordCount" : "575",
  "inLanguage": "en",
  "image":"https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg","datePublished": "2024-03-24T00:00:00Z",
  "dateModified": "2024-03-24T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "lxmliu2002"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lxmliu2002.github.io/posts/paperreading_jtrans/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "lxmliu2002's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lxmliu2002.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lxmliu2002.github.io/" accesskey="h" title="lxmliu2002&#39;s Blog (Alt + H)">lxmliu2002&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lxmliu2002.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://lxmliu2002.github.io/" title="homepage">
                    <span>homepage</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lxmliu2002.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://lxmliu2002.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      PaperReading_jTrans
    </h1>
    <div class="post-description">
      PaperReading
    </div>
    <div class="post-meta"><span title='2024-03-24 00:00:00 +0000 UTC'>March 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;lxmliu2002&nbsp;|&nbsp;<a href="https://github.com/lxmliu2002/My_Blog/tree/master/content/posts/PaperReading_jTrans.md" rel="noopener noreferrer" target="_blank">Any Suggestions?</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://github.com/lxmliu2002/images/raw/main/homepage/home-bg-03.jpg" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#jtrans-jump-aware-transformer-for-binary-code-similarity-detection" aria-label="jTrans: Jump-Aware Transformer for Binary Code Similarity Detection">jTrans: Jump-Aware Transformer for Binary Code Similarity Detection</a><ul>
                        
                <li>
                    <a href="#%e9%80%9a%e8%af%bb" aria-label="通读">通读</a><ul>
                        
                <li>
                    <a href="#abstract" aria-label="ABSTRACT">ABSTRACT</a></li>
                <li>
                    <a href="#introduction" aria-label="INTRODUCTION">INTRODUCTION</a></li>
                <li>
                    <a href="#problem-definition" aria-label="PROBLEM DEFINITION">PROBLEM DEFINITION</a></li>
                <li>
                    <a href="#related-works" aria-label="Related Works">Related Works</a><ul>
                        
                <li>
                    <a href="#non-ml-based-bcsd-approaches" aria-label="Non-ML-based BCSD Approaches">Non-ML-based BCSD Approaches</a></li>
                <li>
                    <a href="#rning-based-bcsd-approaches" aria-label="rning-based BCSD Approaches">rning-based BCSD Approaches</a></li></ul>
                </li>
                <li>
                    <a href="#methodology" aria-label="METHODOLOGY">METHODOLOGY</a><ul>
                        
                <li>
                    <a href="#overview" aria-label="Overview">Overview</a></li>
                <li>
                    <a href="#binary-function-representation-model" aria-label="Binary Function Representation Model">Binary Function Representation Model</a><ul>
                        
                <li>
                    <a href="#preprocessing-instructions" aria-label="Preprocessing instructions">Preprocessing instructions</a></li>
                <li>
                    <a href="#modeling-jump-instructions" aria-label="Modeling jump instructions">Modeling jump instructions</a></li>
                <li>
                    <a href="#the-rationale-of-our-proposed-approach" aria-label="The Rationale of Our Proposed Approach">The Rationale of Our Proposed Approach</a></li></ul>
                </li>
                <li>
                    <a href="#pre-training-jtrans" aria-label="Pre-training jTrans">Pre-training jTrans</a><ul>
                        
                <li>
                    <a href="#the-masked-language-model-task" aria-label="The Masked Language Model Task">The Masked Language Model Task</a></li>
                <li>
                    <a href="#jump-target-prediction" aria-label="Jump Target Prediction">Jump Target Prediction</a></li></ul>
                </li>
                <li>
                    <a href="#fine-tuning-for-binary-similarity-detection" aria-label="Fine-tuning for Binary Similarity Detection">Fine-tuning for Binary Similarity Detection</a></li>
                <li>
                    <a href="#large-scale-dataset-construction" aria-label="Large-Scale Dataset Construction">Large-Scale Dataset Construction</a><ul>
                        
                <li>
                    <a href="#projects-filtering" aria-label="Projects Filtering">Projects Filtering</a></li>
                <li>
                    <a href="#compilation-pipeline" aria-label="Compilation pipeline">Compilation pipeline</a></li>
                <li>
                    <a href="#label-collection" aria-label="Label Collection">Label Collection</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#experimental-setup" aria-label="EXPERIMENTAL SETUP">EXPERIMENTAL SETUP</a><ul>
                        
                <li>
                    <a href="#the-binarycorp-dataset" aria-label="The BinaryCorp Dataset">The BinaryCorp Dataset</a></li>
                <li>
                    <a href="#baselines" aria-label="Baselines">Baselines</a></li>
                <li>
                    <a href="#evaluation-metrics" aria-label="Evaluation Metrics">Evaluation Metrics</a></li></ul>
                </li>
                <li>
                    <a href="#evaluation" aria-label="EVALUATION">EVALUATION</a><ul>
                        
                <li>
                    <a href="#biniary-similarity-detection-performance" aria-label="Biniary Similarity Detection Performance">Biniary Similarity Detection Performance</a></li>
                <li>
                    <a href="#the-effects-of-poolsize-on-performance" aria-label="The Effects of Poolsize on Performance">The Effects of Poolsize on Performance</a></li>
                <li>
                    <a href="#real-world-vulnerability-search" aria-label="Real-World Vulnerability Search">Real-World Vulnerability Search</a></li>
                <li>
                    <a href="#the-impact-of-our-jump-aware-design" aria-label="The Impact of Our Jump-aware Design">The Impact of Our Jump-aware Design</a></li>
                <li>
                    <a href="#evaluating-the-efficacy-of-pre-training" aria-label="Evaluating the Efficacy of Pre-training">Evaluating the Efficacy of Pre-training</a></li></ul>
                </li>
                <li>
                    <a href="#discussion" aria-label="DISCUSSION">DISCUSSION</a></li>
                <li>
                    <a href="#conclusion" aria-label="CONCLUSION">CONCLUSION</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="references">references</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="jtrans-jump-aware-transformer-for-binary-code-similarity-detection">jTrans: Jump-Aware Transformer for Binary Code Similarity Detection<a hidden class="anchor" aria-hidden="true" href="#jtrans-jump-aware-transformer-for-binary-code-similarity-detection">#</a></h1>
<h2 id="通读">通读<a hidden class="anchor" aria-hidden="true" href="#通读">#</a></h2>
<h3 id="abstract">ABSTRACT<a hidden class="anchor" aria-hidden="true" href="#abstract">#</a></h3>
<p>二进制代码相似性检测（Binary code similarity detection，BCSD）在漏洞分析、软件构建分析和逆向工程等领域有着重要应用。现有的工作表明深度神经网络（DNNs）可以理解二进制代码的指令或者是控制流图，并支持 BCSD。本文中，作者提出了一个新的基于 transformer 的方法 jTrans，来学习二进制代码的表示。这是第一个将二进制代码的控制流信息嵌入到基于 transformer 的语言模型中的解决方案，通过使用所分析的二进制代码的新的跳跃感知表示和新设计的预训练任务。</p>
<h3 id="introduction">INTRODUCTION<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>Binary code similarity detection(BCSD)可以识别两个二进制代码片段之间的相似程度，这有着广泛的应用，包括已知的漏洞发现，恶意软件检测和聚类，软件剽窃检测，补丁分析，以及软件供应链分析。</p>
<p>在机器学习应用到该领域之前，传统的 BCSD 严重依赖于手工提取的 CFG 特征，它可以捕获句法知识，如 bindiff 采用图同构技术来计算两个函数的 CFG 之间的相似性，但这种相似性可能会根据编译器的优化而改变，而注入 bingo 等方案通过计算 CFG 片段的相似性来实现对 CFG 变化的更大稳健性。这些手工特征很难捕捉到二进制代码的精确语义，因此仅具备较低的准确性。</p>
<p>一般来讲，这些解决方案是将目标二进制代码嵌入到向量中，并计算函数在向量空间的相似度。一些解决方案，如 Asm2Vec 和 SAFE，使用受自然语言处理（NLP）启发的语言模型来建模汇编语言(机器代码)。其他研究使用图神经网络 (GNNs) 来学习 CFGs 的表示并计算它们的相似性。一些研究结合了这两种方法，通过 NLP 技术学习基本块的表示，并通过 GNN 进一步处理CFG中的基本块特征。尽管性能有所提高，但现有方法有一些局限性。</p>
<p>首先，基于 NLP 的汇编语言建模只考虑了指令的顺序以及它们之间的关系；没有考虑有关程序实际执行（例如控制流）的信息。因此，仅依靠 NLP 的方法将缺乏对分析二进制文件的语义理解，而且也不能很好的适应代码中可能出现的重大变化，这些变化是编译器所带来的结果。</p>
<p>其次，仅依靠 CFG 会错过每个基本块中指令的语义。使用 GNN 来处理 CFG 只能捕获结构信息，且难以并行训练和使用。</p>
<p>第三，现有的解决方案的数据集不够大，不够多样化，缺乏一个通用的基准。</p>
<p>在本文中，提出了 jTrans，一种新颖的基于 Transformer 的模型，旨在解决上述问题并支持现实世界的二进制相似性检测。我们将捕获指令语义的 NLP 模型与捕获控制流信息的 CFG 相结合，以推断二进制代码的表示。将控制流信息融合到 Transformer 架构中</p>
<p>作者通过为每个跳转指令目标共享 token embeddings 和 position embeddings 之间的参数来修改 Transformer 以捕获控制流信息。首先使用无监督学习任务预训练 jTrans，来学习二元函数指令的语义和控制流信息。接着对预训练的 jTrans 进行微调，来匹配语义相似的函数。</p>
<p>除此之外，还提出了一个庞大而多元化的数据集 BinaryCorp。新创建的数据集能够减轻现有数据集的过拟合和缺乏多样性问题。</p>
<p>本文实现了 jTrans，并在真实的 BCSD 问题上进行了评估验证。</p>
<ul>
<li>提出了一个新颖的基于跳跃感知的 Transformer 的模型 jTrans</li>
<li>创建了一个数据集 BinaryCorp</li>
<li>进行了广泛实验进行验证</li>
</ul>
<h3 id="problem-definition">PROBLEM DEFINITION<a hidden class="anchor" aria-hidden="true" href="#problem-definition">#</a></h3>
<p>BCSD 是一个计算二元函数相似度的基本任务，可用于以下 3 种情况：</p>
<ol>
<li>一对一，返回一个源函数与目标函数的相似度分数</li>
<li>一对多，返回目标函数与函数池中所有函数的相似度分数</li>
<li>多对多，根据相似度将函数池分为若干组</li>
</ol>
<p>本文主要研究一对多问题。</p>
<p>下图所示了一个二进制函数的例子，左边是线性的汇编指令，右边是 CFG 控制流图；</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324170504797.png" alt="image-20240324170504797" style="zoom:50%;" />
<p>BCSD 的目标是开发一个解决方案来计算两个函数之间的相似度分数，其中两个函数由两个相同或相似的源代码函数编译。</p>
<h3 id="related-works">Related Works<a hidden class="anchor" aria-hidden="true" href="#related-works">#</a></h3>
<h4 id="non-ml-based-bcsd-approaches">Non-ML-based BCSD Approaches<a hidden class="anchor" aria-hidden="true" href="#non-ml-based-bcsd-approaches">#</a></h4>
<p>机器学习之前，传统的 BCSD 包括静态技术和动态方法。在逻辑上相似的代码具有相似的运行行为的假设前提下，动态分析通过分析手工制作的动态特征来衡量二进制代码相似度。然而，由于基本块拆分，无法用于不同编译器优化的情况等。这些动态方法的主要缺点是不适合大规模二进制代码相似度检测。</p>
<p>而 BCSD 的静态方法是基于是识别二进制代码中的结构差异。静态方法比动态方法有效，但由于其只捕获二进制的结构和句法信息，忽略指令之间的语义关系导致精度较低。</p>
<h4 id="rning-based-bcsd-approaches">rning-based BCSD Approaches<a hidden class="anchor" aria-hidden="true" href="#rning-based-bcsd-approaches">#</a></h4>
<p>基于学习的 BCSD 的研究受到自然语言处理 (NLP) 的最新发展的启发，它使用称为嵌入的实值向量来编码单词和句子的语义信息。如图，使用深度学习算法使逻辑上相似的二元函数的向量距离更接近。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324173954799.png" alt="image-20240324173954799" style="zoom:50%;" />
<p>在 BCSD 领域也探索了无监督学习。</p>
<p>基于学习的方法适用于大规模二进制代码相似度检测，因为二进制代码函数可以转化为向量。然后使用向量距离计算相似度，计算效率很高。但是或多或少都存在一些问题，如忽略指令和基本块的语义、忽略结构信息、忽略指令之间的关系等。</p>
<h3 id="methodology">METHODOLOGY<a hidden class="anchor" aria-hidden="true" href="#methodology">#</a></h3>
<h4 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h4>
<p>jTransis 基于 Transformer-Encoder 架构，用于自动学习二进制程序的指令语义和控制流信息，由几个重要的变化组成，旨在使其对二进制分析的挑战性领域更有效。</p>
<ol>
<li>首先对输入二进制汇编代码进行预处理，使其包含程序的跳转关系，即控制流信息。修改 Transformer 的单个输入 token 的 embedding，使得跳转的起点和终点位置在语义上相似。</li>
<li>鉴于自然语言和程序在数据流方面的相似性，本文选择使用 MLM 的 Transformer 训练方法。Masked language model(MLM) 要求根据邻居的内容来预测屏蔽的标记内容，从而迫使模型对指令之间的关系形成上下文理解。增加辅助训练任务，要求模型理解跳转指令的目标。</li>
</ol>
<p>此外，为了鼓励模型学习跳转合并到代码中的方式，我们提出了一种新颖的辅助训练任务，该任务要求模型预测跳转指令的目标。我们称之为 Jump Target Prediction (JTP) 的任务需要对代码的语义进行深入的理解。</p>
<h4 id="binary-function-representation-model">Binary Function Representation Model<a hidden class="anchor" aria-hidden="true" href="#binary-function-representation-model">#</a></h4>
<p>jTrans 基于 BERT 架构，使用 BERT 使用的相同方法对文本进行建模，但是二进制代码与自然语言有许多不同，如二进制代码的词汇表；二进制代码的跳转指令。</p>
<p>要应用 BERT，必须解决两个问题。</p>
<ol>
<li>词汇外的 token。jTrans 只能在固定词汇表上进行训练，不在上面的需要以一种使 Transformer 能够有效地处理的方式表示。</li>
<li>对 jump 指令建模。预处理后，源 token 与目标 token 之间的有效信息所剩极少，BERT 很难推断它们之间的关联关系，这使得上下文推断更加困难。</li>
</ol>
<h5 id="preprocessing-instructions">Preprocessing instructions<a hidden class="anchor" aria-hidden="true" href="#preprocessing-instructions">#</a></h5>
<p>为了缓解 OOV 问题，本文使用 IDA 分析输入的二进制程序并生成汇编指令序列，然后使用如下标记化策略来规范和减少词汇量：</p>
<ol>
<li>使用操作码和操作数作为 token</li>
<li>使用代替字符串</li>
<li>使用代替常量值</li>
<li>外部函数调用保留，内部函数调用进行替换</li>
<li>对于跳转对，使用 JUMP_XXX 进行替换</li>
</ol>
<h5 id="modeling-jump-instructions">Modeling jump instructions<a hidden class="anchor" aria-hidden="true" href="#modeling-jump-instructions">#</a></h5>
<p>本文使用位置编码使得模型能够确定 token 之间的距离，并且修改位置编码机制以反映 JUMP 指令的效果，通过参数共享使其具有很强的上下文联系。</p>
<p>本文只关注直接跳转指令，间接跳转识别是一个公开挑战，目前还无法处理。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324194057881.png" alt="image-20240324194057881" style="zoom: 33%;" />
<h5 id="the-rationale-of-our-proposed-approach">The Rationale of Our Proposed Approach<a hidden class="anchor" aria-hidden="true" href="#the-rationale-of-our-proposed-approach">#</a></h5>
<p>通过共享参数，在表示中创建了高度的相似性。当 jTrans 为其分配高注意力权重时，将自动为其伙伴分配高注意力，确保跳转指令的两个部分以及其附近的指令能够包括其中。</p>
<h4 id="pre-training-jtrans">Pre-training jTrans<a hidden class="anchor" aria-hidden="true" href="#pre-training-jtrans">#</a></h4>
<p>jTrans 所基于的 BERT 架构使用两个无监督学习任务进行预训练。第一个任务是掩码语言模型 (MLM)， BERT 的任务是重建随机掩码标记。第二个无监督学习任务旨在通过判断两个句子是否连续来磨练 BERT 的上下文能力。建立在 BERT 的整体训练过程的基础上，同时进行特定领域的适应：保留 MLM 任务，但用称为跳转目标预测 (JTP) 的任务取代第二个任务。</p>
<h5 id="the-masked-language-model-task">The Masked Language Model Task<a hidden class="anchor" aria-hidden="true" href="#the-masked-language-model-task">#</a></h5>
<p>jTrans 使用 BERT 的掩码过程：我们随机选择的 80% 的标记被掩码标记替换（表明它们需要重建），10% 被其他随机标记替换，10% 保持不变。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324195625443.png" alt="image-20240324195625443" style="zoom:67%;" />
<p>MLM 的例子如下。为了成功，我们的模型必须学习基本的组装语法及其上下文信息。例如，成功重建 rdi 令牌需要模型学习函数的调用约定，而 rsp 令牌需要了解连续执行。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324195717062.png" alt="image-20240324195717062" style="zoom:50%;" />
<h5 id="jump-target-prediction">Jump Target Prediction<a hidden class="anchor" aria-hidden="true" href="#jump-target-prediction">#</a></h5>
<p>JTP 任务定义如下: 给定一个随机选择的跳转源 token，模型被要求去预测相应的目标 token。这项任务，即使对人类专家来说也是困难的，需要我们的模型对 CFG 有深刻的理解。这反过来又提升了 jTrans 的性能。JTP 的实现首先从可用的跳转源 token 中随机选择一个子集。然后将这些标记替换为标记 &lt;LOC&gt;。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324195920531.png" alt="image-20240324195920531" style="zoom: 67%;" />
<p>JTP 的例子如下。将 JUMP_20 替换成 &lt;LOC&gt;，模型的任务是预测索引。该训练任务提高了jTrans学习分析函数的控制流的能力。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324195944373.png" alt="image-20240324195944373" style="zoom:50%;" />
<p>jTrans 在预训练阶段的整体损失函数是 MLM 和 JTP 目标函数的总和：</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324200156042.png" alt="image-20240324200156042" style="zoom:67%;" />
<h4 id="fine-tuning-for-binary-similarity-detection">Fine-tuning for Binary Similarity Detection<a hidden class="anchor" aria-hidden="true" href="#fine-tuning-for-binary-similarity-detection">#</a></h4>
<p>为了使相同的函数对距离最小，使不相同的函数对距离最大，通过对比学习的目标函数微调训练。目标函数如下：</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324200438203.png" alt="image-20240324200438203" style="zoom:67%;" />
<h4 id="large-scale-dataset-construction">Large-Scale Dataset Construction<a hidden class="anchor" aria-hidden="true" href="#large-scale-dataset-construction">#</a></h4>
<p>我们基于 ArchLinux 官方存储库和 Arch User Repository 构建了用于二进制相似性检测的数据集。</p>
<h5 id="projects-filtering">Projects Filtering<a hidden class="anchor" aria-hidden="true" href="#projects-filtering">#</a></h5>
<p>使用 C 或 C++ 项目构建数据集，其他的予以删除。</p>
<h5 id="compilation-pipeline">Compilation pipeline<a hidden class="anchor" aria-hidden="true" href="#compilation-pipeline">#</a></h5>
<p>将环境变量指定为 gcc、g++、clang、clang++ 的自修改版本。修改后的编译器更改与优化级别相关的命令行参数，以预期编译参数。此外，它将预期的编译参数附加到原始参数。我们使用这两种方法来确保编译是使用预期的优化级别完成的。</p>
<h5 id="label-collection">Label Collection<a hidden class="anchor" aria-hidden="true" href="#label-collection">#</a></h5>
<p>需要首先获得未剥离的二进制并获得函数的偏移量。用修改后的版本替换了 strip。无论传递的参数如何，它不会剥离符号表。</p>
<h3 id="experimental-setup">EXPERIMENTAL SETUP<a hidden class="anchor" aria-hidden="true" href="#experimental-setup">#</a></h3>
<h4 id="the-binarycorp-dataset">The BinaryCorp Dataset<a hidden class="anchor" aria-hidden="true" href="#the-binarycorp-dataset">#</a></h4>
<p>BinaryCorp 由自动编译管道产生的大量二进制文件组成。数据集的统计数据如图所示。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324201455709.png" alt="image-20240324201455709" style="zoom:50%;" />
<h4 id="baselines">Baselines<a hidden class="anchor" aria-hidden="true" href="#baselines">#</a></h4>
<p>使用 jTrans 与六个表现最佳的 baseline 进行比较：</p>
<ol>
<li>Genius，非深度学习方法。以属性控制流图的形式提取原始特征，并使用位置敏感散列 (LSH) 生成数字向量以进行漏洞搜索。</li>
<li>Gemini，为每个基本块提取手工制作的特征，并使用 GNN 来学习分析函数的 CFG 表示。</li>
<li>SAFE，使用具有注意力机制的 RNN 架构来生成分析函数的表示，它接收汇编指令作为输入。</li>
<li>Asm2Vec，使用 CFG 上的随机游走对指令序列进行采样，然后使用 PV-DM 模型联合学习函数和指令标记的嵌入。</li>
<li>GraphEmb，使用 word2vec 来学习指令 token 的 embedding。接下来，它使用 RNN 为每个基本块生成独立的 embedding，最后使用 structure2vec 来组合嵌入并生成分析函数的表示。</li>
<li>OrderMatters，该方法结合了两种类型的 embedding。第一个 embedding 类型使用 BERT 为每个基本块创建一个 embedding，然后使用 GNN 组合所有这些 embedding 以生成最终表示。第二种 embedding 是通过在 CFG 上应用 CNN 获得的。然后将这两个 embedding 连接起来。</li>
</ol>
<h4 id="evaluation-metrics">Evaluation Metrics<a hidden class="anchor" aria-hidden="true" href="#evaluation-metrics">#</a></h4>
<h3 id="evaluation">EVALUATION<a hidden class="anchor" aria-hidden="true" href="#evaluation">#</a></h3>
<h4 id="biniary-similarity-detection-performance">Biniary Similarity Detection Performance<a hidden class="anchor" aria-hidden="true" href="#biniary-similarity-detection-performance">#</a></h4>
<p>本文对这两个数据集进行评估，BinaryCorp-3M 和 BinaryCorp-26M，使用两个函数池大小 32 和 10,000，以便 jTrans 和 baseline 可以以不同程度的难度进行评估。实验结果如下所示，jTrans 极大优于其他模型。对于 poolsize=32 （表 2 和 4），jTrans 在 MRR 指标上比最接近的基准竞争对手高出 0.07，在 recall@1 指标上高出 10% 以上。当我们在较大的池规模（10000）上评估模型时，性能上的差异变得更加明显。对于这种设置，其结果如表 3 和表 5 所示，jTrans 在 MRR 指标上比最接近的竞争对手高出 0.26，在 recall@1 指标上高出 27%。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324210001492.png" alt="image-20240324210001492" style="zoom: 42%;" />
<h4 id="the-effects-of-poolsize-on-performance">The Effects of Poolsize on Performance<a hidden class="anchor" aria-hidden="true" href="#the-effects-of-poolsize-on-performance">#</a></h4>
<p>现在深入分析池大小对二进制分析 SOTA 方法性能的影响。结果如图所示。对不同的池大小 (2、10、32、128、512、1000 和 10000) 进行了多次实验，并绘制了各种优化对的结果。结果表明，随着池大小的增加，所有 baseline 的相对性能都比 jTrans 差。要指出的是，对于非常小的池大小（例如 2），SOTA baseline（如 SAFE 和 Asm2Vec）的性能几乎与 jTrans 相同，后者的性能比 jTrans 高出约 2%。在小池上评估二进制分析工具并不能为它们在现实世界中的性能提供有意义的指示。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324210406519.png" alt="image-20240324210406519" style="zoom:33%;" />
<h4 id="real-world-vulnerability-search">Real-World Vulnerability Search<a hidden class="anchor" aria-hidden="true" href="#real-world-vulnerability-search">#</a></h4>
<p>将 jTrans 应用于一个已知的漏洞数据集，目的是搜索有漏洞的函数。下图显示了每个查询的 recall@10 度量的结果。将所提出方法与来自 SAFE 和 Asm2Vec 的两个主要基线进行了比较。例如，在包含 3038 个函数的 openjpeg 项目中的 CVE-2016-3183 上，所提出方法实现了 100% 的 top-10 召回率，这意味着它成功地检索了所有 10 个变体，而 Asm2Vec 和 SAFE 分别实现了 recall@10 值的 36.9% 和 28.6%。实验结果表明，jTrans 能够在大池规模上表现良好，因此可以在现实场景中有效部署作为漏洞搜索工具。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324210816548.png" alt="image-20240324210816548" style="zoom:50%;" />
<h4 id="the-impact-of-our-jump-aware-design">The Impact of Our Jump-aware Design<a hidden class="anchor" aria-hidden="true" href="#the-impact-of-our-jump-aware-design">#</a></h4>
<p>测试跳变感知设计极大地提高了 jTrans 分析二进制代码 CFG 的能力。本文训练了一个标准的 BERT 模型，该模型不使用我们对跳转信息的表示，并将其与我们的方法进行比较。与 SAFE 类似，标准 BERT 不接收控制流信息，只能从汇编序列信息中学习。使用 Recall@1 评估了 BinaryCorp- 3M 上的标准 BERT 模型和 jTrans, poolsize=10,000。我们的评估结果如图所示。结果表明，标准 BERT 的性能明显低于 jTrans，因为它在每个优化对上的性能都较低。平均而言，jTrans 比 BERT 高出 7.3%。这些结果清楚地表明，在汇编语言序列建模中加入控制流信息对我们的模型是非常有益的。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324212227324.png" alt="image-20240324212227324" style="zoom:50%;" />
<p>为了进一步探索该设计的有效性，本文分析的预训练模型预测二进制代码中掩码跳跃地址的能力。在 BinaryCorp-3M 上进行了实验。对于评估集中的每个函数，我们随机抽取一些概率为 15% 的跳跃位置，并用函数中的 &lt;LOC&gt; 替换它们。然后，我们分析了模型正确预测每个掩码跳转目标的跳转目标位置的概率。如表所示，表明 jTrans 能够预测跳跃位置。我们的预训练模型可以预测跳跃指令的目标，top-1 准确率为 92.9%，top-10 准确率为 99.5%。这种准确性非常高，特别是对于 top-1，因为有 512 个可能的跳跃位置。这些结果表明我们的预训练模型能够成功捕获二进制的上下文指令信息。</p>
<img src="https://github.com/lxmliu2002/images/raw/main/post/20240324/image-20240324212544977.png" alt="image-20240324212544977" style="zoom:50%;" />
<h4 id="evaluating-the-efficacy-of-pre-training">Evaluating the Efficacy of Pre-training<a hidden class="anchor" aria-hidden="true" href="#evaluating-the-efficacy-of-pre-training">#</a></h4>
<p>和最初的 BERT 一样，预训练是我们模型的关键组成部分。它的主要优点是可以在未标记的数据上执行，这更容易获得大量的数据。为了评估预训练方法(MLM和JTP)的有效性，我们评估了不进行任何微调的模型版本。遵循与零样本学习相同的方法，在预训练阶段使用没有标签信息的二进制文件。然后，在不微调预训练模型的情况下，立即将其应用于二进制相似性搜索任务。该模型的计算结果记为 jTrans-zero，如表 2-5 所示。可以看到，集市没有微调，jTrans-zero 也优于 poolsize=10000 的所有 baseline。</p>
<h3 id="discussion">DISCUSSION<a hidden class="anchor" aria-hidden="true" href="#discussion">#</a></h3>
<p>现有的基于深度学习的作品，以及 jTrans，将单个二元函数嵌入到数值向量中，并比较向量之间的相似性。因此，它们的准确性随着池大小而下降。如图 6 所示，如果池大小为 10,000，大多数现有解决方案的准确率下降到 20% 以下。在现实世界中，池的大小会大得多。直接将两个二元函数作为输入的模型可以更好地捕获函数间关系，进一步提高 BCSD 的性能，即使在大池中。然而，训练一个模型直接比较两个函数会有更高的开销。我们将在现实世界 BCSD 任务中使用 jTrans 作为未来工作时平衡准确性和开销。</p>
<h3 id="conclusion">CONCLUSION<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>在这项工作中，我们提出了 jTrans，这是第一个将控制流信息嵌入到基于 Transformer 的语言模型的解决方案。我们的方法利用了一种新颖的跳跃感知架构设计，不依赖于 GNN 的使用。实验结果表明，我们的方法在 BCSD 任务上始终优于最先进的方法。通过密集评估，我们还发现了对当前 SOTA 方法评估的弱点。此外，我们向社区展示和发布一个名为 BinaryCorp 的新创建的数据集。我们的数据集迄今为止包含最多的多样化二进制文件，我们相信它可以用作该领域未来研究的高质量基准。</p>
<h2 id="references">references<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p><a href="https://blog.csdn.net/AcSuccess/article/details/127161840">https://blog.csdn.net/AcSuccess/article/details/127161840</a></p>
<p><a href="https://blog.csdn.net/qq_33976344/article/details/130782176">https://blog.csdn.net/qq_33976344/article/details/130782176</a></p>
<p><a href="https://www.youtube.com/watch?v=rAirmnUsC1k">https://www.youtube.com/watch?v=rAirmnUsC1k</a></p>
<p><a href="https://mp.weixin.qq.com/s/xvKRGY6Vbaj_XHys7kqz2A">https://mp.weixin.qq.com/s/xvKRGY6Vbaj_XHys7kqz2A</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lxmliu2002.github.io/tags/binary-code-search/">Binary-Code-Search</a></li>
      <li><a href="https://lxmliu2002.github.io/tags/vulnerability-search/">Vulnerability-Search</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lxmliu2002.github.io/posts/paperreading_how_machine_learning_is_solving_the_binary_function_similarity_problem/">
    <span class="title">« Prev</span>
    <br>
    <span>PaperReading_How_Machine_Learning_Is_Solving_the_Binary_Function_Similarity_Problem</span>
  </a>
  <a class="next" href="https://lxmliu2002.github.io/posts/paperreading_sann/">
    <span class="title">Next »</span>
    <br>
    <span>PaperReading_SANN</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on x"
            href="https://x.com/intent/tweet/?text=PaperReading_jTrans&amp;url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f&amp;hashtags=Binary-Code-Search%2cVulnerability-Search">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f&amp;title=PaperReading_jTrans&amp;summary=PaperReading_jTrans&amp;source=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f&title=PaperReading_jTrans">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on whatsapp"
            href="https://api.whatsapp.com/send?text=PaperReading_jTrans%20-%20https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on telegram"
            href="https://telegram.me/share/url?text=PaperReading_jTrans&amp;url=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PaperReading_jTrans on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=PaperReading_jTrans&u=https%3a%2f%2flxmliu2002.github.io%2fposts%2fpaperreading_jtrans%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/lxmliu2002">lxmliu2002</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
